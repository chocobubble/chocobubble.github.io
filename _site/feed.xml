<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-05-29T21:51:14+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Take responsibility for our dreams</title><subtitle>SITE DESCRIPTION.</subtitle><author><name>Chocobubble</name></author><entry><title type="html">자료 구조 - 리스트</title><link href="http://localhost:4000/ds/ds-6-list/" rel="alternate" type="text/html" title="자료 구조 - 리스트" /><published>2023-05-29T00:00:00+09:00</published><updated>2023-05-29T00:00:00+09:00</updated><id>http://localhost:4000/ds/ds-6-list</id><content type="html" xml:base="http://localhost:4000/ds/ds-6-list/"><![CDATA[<blockquote>
  <p>‘c++로 쉽게 풀어쓴 자료구조 1판 - 천인국, 최영규’ 책을 참고하여 작성한 포스트입니다.</p>
</blockquote>

<h1 id="리스트">리스트</h1>
<h2 id="리스트란">리스트란?</h2>
<blockquote>
  <p>리스트(list) 또는 선형 리스트(linear list)는 항목들 사이에 순서가 있는 선형 자료구조이다. 리스트의 특징은 <u> 임의의 위치에 있는 항목에 대한 연산을 허용하는 것이다. </u></p>
</blockquote>

<h3 id="연결-리스트와의-차이">연결 리스트와의 차이</h3>
<ul>
  <li><strong>리스트</strong>는 특정한 자료 구조를 말하며, <strong>연결 리스트</strong>는 어떤 자료 구조를 구현하는 <strong>프로그래밍 기법</strong>이다.</li>
</ul>

<h2 id="리스트의-추상-자료형">리스트의 추상 자료형</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>데이터: 임의의 접근 방법을 제공하는 같은 타입 요소들의 순서 있는 모임  
연산
 - insert(pos, item): 리스트의 pos 위치에 새로운 요소 item을 삽입
 - delete(pop): 리스트의 pos 위치에 있는 요소를 삭제한다.
 - getEntry(pos): 리스트의 pos 위치에 있는 요소를 반환한다.
 - isEmpty(): 리스트가 비어 있는지를 검사한다.
 - isFull(): 리스트가 가득 차 있는지를 검사한다.
 - find(item): 리스트에 요소 item이 있는지를 검사한다.
 - replace(pos, item): 리스트의 pos 위치에 있는 요소를 새로운 요소 item으로 바꾼다.
 - size(): 리스트 안의 요소의 개수를 반환한다.
 - display(): 리스트 안의 모든 요소들을 출력한다. 
</code></pre></div></div>]]></content><author><name>Chocobubble</name></author><category term="DS" /><category term="DS, List" /><summary type="html"><![CDATA[C++로 쉽게 풀어쓴 자료구조 1판 - 천인국, 최영규]]></summary></entry><entry><title type="html">개인 자료 3</title><link href="http://localhost:4000/job/lecture-3/" rel="alternate" type="text/html" title="개인 자료 3" /><published>2023-05-29T00:00:00+09:00</published><updated>2023-05-29T00:00:00+09:00</updated><id>http://localhost:4000/job/lecture-3</id><content type="html" xml:base="http://localhost:4000/job/lecture-3/"><![CDATA[<h1 id="프로세스-메모리-구조">프로세스 메모리 구조</h1>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nf">SomeClass</span><span class="p">()</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">staticNum</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">SomeClass</span><span class="p">()</span> <span class="p">{};</span>
    <span class="o">~</span><span class="n">SomeClass</span><span class="p">();</span>
    <span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">n1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">SomeClass</span><span class="o">::</span><span class="n">staticNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"abcd"</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>
<ol>
  <li>코드 영역
    <ul>
      <li>실행하는 프로그램의 코드를 저장하는 공간
        <ul>
          <li><u> 위의 코드 일체가 기계어로 바뀌어 저장됨 </u></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>데이터 영역
    <ul>
      <li>리터럴
        <ul>
          <li>소스코드에 고정된 값</li>
          <li>변수 값이 변하지 않는 데이터</li>
          <li><u> 위의 코드에서 1, 2, "abcd" 등 </u></li>
          <li><u> 리터럴들을 저장함으로써 메모리 효율 추구 </u></li>
          <li><u> int an = 10;... 이 변수가 달라지면서 백만번 반복 된다면, 10을 하나만 데이터 영역에 저장함으로써 메모리 아낌 </u></li>
        </ul>
      </li>
      <li>전역 변수</li>
      <li>스태틱 변수
        <ul>
          <li><u> 위의 코드에서 static </u>
            <ul>
              <li>스택</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>프로그램에서 사용되는 임시 메모리 영역</li>
      <li>현재 실행되고 있는 구역의 지역 변수나 함수 정보가 저장</li>
      <li>프로그램이 실행되면서 늘어났다가 줄었다가 반복함.</li>
      <li>스택의 용량은 윈도우 기준 기본값이 1MB입니다.
        <ul>
          <li>컴파일러 옵션에서 조절이 가능합니다.</li>
        </ul>
      </li>
      <li><u> 현재 프로그램의 흐름을 저장. </u>
    - 힙</li>
      <li>프로그래머가 제어하는 메모리 공간
        <ul>
          <li>new 를 가지고 메모리를 할당하고, delete 메모리를 삭제</li>
        </ul>
      </li>
      <li>메모리 할당을 하고, 사용하지 않으면 제거를 해줘야 됨</li>
    </ul>
  </li>
</ol>]]></content><author><name>Chocobubble</name></author><category term="job" /><category term="Nothing" /><summary type="html"><![CDATA[정리 전 자료]]></summary></entry><entry><title type="html">c++ vector 구현</title><link href="http://localhost:4000/self_implement/lecture-3-todo/" rel="alternate" type="text/html" title="c++ vector 구현" /><published>2023-05-29T00:00:00+09:00</published><updated>2023-05-29T00:00:00+09:00</updated><id>http://localhost:4000/self_implement/lecture-3-todo</id><content type="html" xml:base="http://localhost:4000/self_implement/lecture-3-todo/"><![CDATA[<h1 id="c-의-vector-구현">C++ 의 Vector 구현</h1>
<h3 id="구현-할-내용">구현 할 내용</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MyVector
    - 정수형을 저장하는 동적 배열입니다.
    - 생성자
        - MyVector vec
            - 비어있는 MyVector를 생성
        - MyVector vec(10)
            - 기본값(0)으로 초기화 된 10개의 원소를 가지는 MyVector를 생성
    - 함수
        - empty()
            - 비어잇으면 true, 아니면 false
        - push_back(1)
            - 마지막 원소 뒤에 1을 삽입
        - size()
            - 현재 원소 들어가 있는 갯수
        - capacity()
            - 현재 MyVector 할당된 메모리 크기
        - clear()
        - at(1)
            - 특정 인덱스로 접근
        - find(2)
            - 2를 찾아서 있으면 인덱스, 없으면 -1
        - vec[1]
            - 첨자 연산
</code></pre></div></div>

<h2 id="배열로-vector-구현">배열로 vector 구현</h2>
<h3 id="필요-변수">필요 변수</h3>
<ul>
  <li>vecCapacity: 배열의 크기</li>
  <li>length: 배열 내 요소들의 개수, 새로운 요소가 맨 뒤에 추가될 때 삽입되어야 하는 위치</li>
  <li>array: 원소들을 담을 배열</li>
</ul>

<h3 id="myvector-class">MyVector class</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyVector</span><span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">vecCapacity</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">vector</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="c1">// 생성자. 초기 배열은 크기3 으로 생성  </span>
    <span class="n">MyVector</span><span class="p">(</span><span class="kt">int</span> <span class="n">vecCapacity</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="o">:</span> <span class="n">vecCapacity</span><span class="p">(</span><span class="n">vecCapacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">vecCapacity</span><span class="p">];</span>
        <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">MyVector</span><span class="p">(){</span> <span class="k">delete</span> <span class="p">[]</span> <span class="n">vector</span><span class="p">;</span> <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="nb">true</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 벡터에 남은 공간이 있는 지 확인</span>
        <span class="c1">// 없으면 크기를 늘린 후 삽입</span>
        <span class="k">if</span><span class="p">(</span><span class="n">isFull</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">expandVector</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">vector</span><span class="p">[</span><span class="n">length</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">length</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">capacity</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">vecCapacity</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">clear</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 포인터는 남아 있나??</span>
        <span class="k">delete</span> <span class="p">[]</span> <span class="n">vector</span><span class="p">;</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">vecCapacity</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">vector</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>


    <span class="kt">bool</span> <span class="nf">isFull</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">length</span> <span class="o">==</span> <span class="n">vecCapacity</span> <span class="o">?</span> <span class="nb">true</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 벡터의 공간이 꽉 찬 상태에서 원소 삽입 시 호출</span>
    <span class="c1">// 벡터의 크기를 늘리고 원래의 배열의 원소들을 복사해 옴</span>
    <span class="kt">void</span> <span class="nf">expandVector</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">vecCapacity</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">tempArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">vecCapacity</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tempArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">tempArray</span><span class="p">;</span>
        <span class="k">delete</span> <span class="p">[]</span> <span class="n">tempArray</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">};</span>
</code></pre></div></div>]]></content><author><name>Chocobubble</name></author><category term="self_implement" /><category term="Task" /></entry><entry><title type="html">자료 구조 - 연결 리스트</title><link href="http://localhost:4000/ds/ds-linkedlist/" rel="alternate" type="text/html" title="자료 구조 - 연결 리스트" /><published>2023-05-29T00:00:00+09:00</published><updated>2023-05-29T00:00:00+09:00</updated><id>http://localhost:4000/ds/ds-linkedlist</id><content type="html" xml:base="http://localhost:4000/ds/ds-linkedlist/"><![CDATA[<blockquote>
  <p>‘c++로 쉽게 풀어쓴 자료구조 1판 - 천인국, 최영규’ 책을 참고하여 작성한 포스트입니다.</p>
</blockquote>

<h1 id="연결리스트">연결리스트</h1>
<h2 id="연결리스트란">연결리스트란?</h2>
<p>앞서 배열로 자료구조를 구현하였을 때, 크기가 고정된다는 단점이 있었다. 동적으로 크기가 변할 수 있는 보다 자유로운 방법으로 <strong>연결된 표현(linked representation)</strong>을 사용하면 된다.</p>
<blockquote>
  <h3 id="연결된-표현">연결된 표현</h3>
  <p>데이터와 링크로 구성되어 있고, 링크가 노드들을 연결하는 역할을 한다.
특징은 다음과 같다.</p>
  <ul>
    <li>데이터를 한군데 모아두는 것을 포기한다</li>
    <li>데이터들은 메인 메모리상의 어디에나 흩어져서 존재할 수 있다.</li>
    <li>순서를 유지하기 위해 각각의 데이터는 다음 데이터를 가리키는 줄(링크)을 가진다.</li>
    <li>첫 데이터에서부터 순서대로 줄을 따라가면 모든 데이터를 방문할 수 있다.</li>
  </ul>
</blockquote>

<blockquote>
  <h3 id="연결리스트linked-list">연결리스트(linked list)</h3>
  <p>물리적으로 흩어져 있는 자료들을 서로 연결하여 하나로 묶는 방법. 
배열과 대응되는 의미로 다음과 같은 장점들이 있다.</p>
  <ul>
    <li>크기가 고정되지 않아 메모리를 할당할 수 있는 한 계속 자료를 넣을 수 있다. 배열의 경우 사용하지 않더라도 한꺼번에 많은 공간을 할당해야 한다.</li>
    <li>중간에 자료를 삽입 혹은 삭제가 용이하다. ($O(1)$)</li>
  </ul>
</blockquote>

<blockquote>
  <p>그러나 연결 리스트는 배열에 비해 상대적으로 구현이 어렵고 데이터 탐색 시 순차적으로 접근해야 한다는 단점이 있다.</p>
</blockquote>

<h2 id="연결-리스트의-구조">연결 리스트의 구조</h2>
<h3 id="노드node">노드(Node)</h3>
<ul>
  <li>연결리스트는 노드들의 집합이며 이들은 데이터를 저장하고 있고 서로 연결되어 있다. 일반적인 노드는 데이터 필드(data field)와 링크 필드(link field)로 구성되어 있다. 데이터 필드에는 저장하고 싶은 자료가 저장되며, 링크 필드에는 다른 노드를 가리키는 포인터 변수가 있다. 이 포인트로 현재 노드에 연결된 다음 노드를 알 수 있다.</li>
</ul>

<h3 id="헤드-포인터head-pointer">헤드 포인터(head pointer)</h3>
<ul>
  <li>헤드 포인터란 연결 리스트에서 첫 번째 노드를 가리키는 포인터이다. 연결 리스트는 첫 번째 노드를 알면 링크로 매달려 있는 전체 노드에 모두 접근이 가능하다.</li>
</ul>

<h3 id="연결-리스트의-단점">연결 리스트의 단점</h3>
<ol>
  <li>링크 필드를 위한 추가 공간이 필요하고,</li>
  <li>연산의 구현이나 사용 방법이 배열에 비해 복잡하다.</li>
  <li>그에 따라 오류가 발생할 가능성도 많으며,</li>
  <li><u>동적 할당과 해제가 너무 빈번하게 일어나는 경우 메모리 관리를 위한 처리 시간이 지나치게 길어져 프로그램이 느려질 수 있다.</u> (이유 추가하기.)</li>
</ol>

<h2 id="연결-리스트의-종류">연결 리스트의 종류</h2>
<blockquote>
  <p>연결 리스트에는 단순 연결 리스트(singly linked list)와 이중 연결 리스트(doubly linked list)가 있다.</p>
</blockquote>

<h3 id="단순-연결리스트">단순 연결리스트</h3>
<ul>
  <li>하나의 방향으로만 연결되어 있으며, 맨 마지막 노드의 링크 필드는 NULL 값을 가진다.</li>
</ul>

<h3 id="이중-연결-리스트">이중 연결 리스트</h3>
<ul>
  <li>다음 장에서 살펴 보겠음!!</li>
</ul>

<h1 id="연결-리스트로-구현한-스택">연결 리스트로 구현한 스택</h1>
<p>저번에 스택을 배열로 구현하였다. 포인터를 이용한 연결 리스트로 구현해 보자.</p>
<ul>
  <li>
    <p>추상 자료형은 이전의 스택과 동일하다.</p>
  </li>
  <li>
    <p>핵심은 삽입, 삭제 등 연산 시 해당 노드를 가리키는 링크를 잃어버리지 않아야 한다는 것이다! {: .notice–primary}</p>
  </li>
</ul>

<h3 id="노드-구현">노드 구현</h3>
<ul>
  <li>먼저 데이터를 담을 클래스를 구현한다.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;csdlib&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp">
#define MAX_STRING 100
</span><span class="c1">// 안의 내용은 중요하지 않음!</span>
<span class="k">class</span> <span class="nc">Data</span> <span class="p">{</span>
    <span class="c1">// 정수하면 가장 먼저 생각 나는 인덱스..</span>
    <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
    <span class="c1">// 정수만 있으면 좀 그러니 문자열도</span>
    <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">MAX_STRING</span><span class="p">];</span>

<span class="nl">public:</span>
    <span class="n">Data</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="o">=</span><span class="s">""</span><span class="p">)</span> <span class="p">{</span>  <span class="n">set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="c1">// 문자열 복사 함수</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">display</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d인덱스의 문자열은 %s이다.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span> <span class="c1">// 빼먹지 말기</span>
</code></pre></div></div>

<ul>
  <li>데이터 클래스에 링크를 포함시켜 노드를 구현한다.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 데이터 필드를 상속으로 처리</span>
<span class="c1">// 상속없이 노드 클래스 내에 </span>
<span class="c1">// Data data; 선언을 해주어도 됨</span>
<span class="cp">#include</span> <span class="cpf">"Data.h"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Node</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Data</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">link</span><span class="p">;</span> <span class="c1">// 링크 필드</span>
<span class="nl">public:</span>
    <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="o">=</span><span class="s">""</span><span class="p">)</span> 
        <span class="o">:</span> <span class="n">Data</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="n">link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// 마지막 노드의 링크는 NULL을 가리켜야 한다.</span>
    <span class="o">~</span><span class="n">Node</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// ~Node() {} 와 동일?</span>

    <span class="c1">// private으로 선언된 link에 접근하기 위한 메소드</span>
    <span class="n">Node</span><span class="o">*</span> <span class="nf">getLink</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">link</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// private으로 선언된 link에 포인터(?)를 할당하기 위한 메소드</span>
    <span class="kt">void</span> <span class="nf">setLink</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">link</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span> <span class="c1">// 빼먹지 말기</span>
</code></pre></div></div>

<h3 id="연산-구현">연산 구현</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"Node.h"</span><span class="cp">
</span><span class="k">class</span> <span class="nc">LinkedStack</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">top</span><span class="p">;</span> <span class="c1">// 헤드 포인터</span>
<span class="nl">private:</span>
    <span class="n">LinkedStack</span><span class="p">()</span> <span class="p">{</span> <span class="n">top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 소멸자 유의 깊게 보기</span>
    <span class="c1">// pop으로 노드를 반환 받아 삭제함</span>
    <span class="o">~</span><span class="n">LinkedStack</span><span class="p">()</span> <span class="p">{</span> <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">())</span> <span class="k">delete</span> <span class="n">pop</span><span class="p">();</span> <span class="p">}</span>

    <span class="c1">// 헤더 포인터가 NULL을 가리키면</span>
    <span class="c1">// 링크드리스트는 빈 것이죠</span>
    <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">top</span><span class="o">==</span><span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 삽입 메소드</span>
    <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span> <span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// stack은 후입 선출이므로</span>
            <span class="c1">// 헤드 포인터를 새로 들어온 p로</span>
            <span class="c1">// 변경해 주어야 한다.</span>
            <span class="n">p</span><span class="p">.</span><span class="n">setLink</span><span class="p">(</span><span class="n">top</span><span class="p">);</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 삭제 메소드</span>
    <span class="n">Node</span><span class="o">*</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 헤드 포인터를 다음 노드로 옮기고</span>
            <span class="c1">// 맨 마지막 노드를 반환한다</span>
            <span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">top</span><span class="o">-&gt;</span><span class="n">getLink</span><span class="p">();</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Node</span><span class="o">*</span> <span class="nf">peek</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 아래와 같이 empty일 때 NULL을 반환하는 경우</span>
        <span class="c1">// empty 체크는 안해도 결과는 NULL로 같다. </span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// top-&gt;getLink() 가 아님!</span>
            <span class="k">return</span> <span class="n">top</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 순회 해 보자!</span>
    <span class="kt">void</span> <span class="nf">display</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 연결 리스트를 수정 하면 안되니까</span>
        <span class="c1">// top이 아닌 새로운 포인터 p로 순회</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">();</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">getLink</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h1 id="연결리스트로-구현한-큐">연결리스트로 구현한 큐</h1>]]></content><author><name>Chocobubble</name></author><category term="DS" /><category term="DS, LinkedList" /><summary type="html"><![CDATA[C++로 쉽게 풀어쓴 자료구조 1판 - 천인국, 최영규]]></summary></entry><entry><title type="html">자료 구조 - 배열</title><link href="http://localhost:4000/ds/ds-2/" rel="alternate" type="text/html" title="자료 구조 - 배열" /><published>2023-05-27T00:00:00+09:00</published><updated>2023-05-27T00:00:00+09:00</updated><id>http://localhost:4000/ds/ds-2</id><content type="html" xml:base="http://localhost:4000/ds/ds-2/"><![CDATA[<blockquote>
  <p>‘c++로 쉽게 풀어쓴 자료구조 1판 - 천인국, 최영규’ 책을 참고하여 작성한 포스트입니다.</p>
</blockquote>

<h1 id="배열array">배열(array)</h1>
<ul>
  <li>배열은 하나의 변수에 여러 개의 값을 순차적으로 저장할 수 있는 자료 구조이다.</li>
  <li>가장 기본적인 특징은 &lt;인덱스, 요소&gt; 쌍의 집합이라는 것이다. 즉, 인덱스가 주어지면 해당하는 요소가 대응되는 자료구조이다.</li>
  <li>C++의 배열에서는 모든 요소가 동일한 자료형이며, 인덱스를 사용하여 요소를 직접 접근(direct access)할 수 있다.</li>
  <li>대응되는 개념으로 연결 리스트가 있다. 순차 접근(sequential access) 방식으로 요소에 하나씩 순서적으로 찾아간다.</li>
</ul>

<h2 id="배열의-추상-자료형">배열의 추상 자료형</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>데이터: &lt;인덱스, 요소&gt; 쌍의 집합
연산
 - craete(n): n개의 요소를 가진 배열을 생성
 - retrieve(i): 배열의 i번째 요소를 반환
 - store(i, item): 배열의 i번째 위치에 item을 저장 
</code></pre></div></div>
<h2 id="1차원-배열">1차원 배열</h2>
<p>선언하는 방법은 다음과 같다</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>자료형 배열이름[배열의_크기];
</code></pre></div></div>
<blockquote>
  <p>배열에서 핵심은 요소들이 모두 메모리의 연속된 공간에 저장된다는 것이다</p>
  <h3 id="문자열">문자열</h3>
  <p>문자열은 1차원 배열의 한 종류로 char 형의 요소를 갖는 배열이다. 문자열의 끝에는 끝을 나타내는 NULL 문자 ‘\0’이 있어야 한다.</p>
</blockquote>

<h2 id="2차원-배열">2차원 배열</h2>
<p>1차원 배열이 여러 개 모여 이루어진다. 가로줄을 행(row), 세로줄을 열(column) 이라고 한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>자료형 배열이름[행의_크기][열의_크기];
</code></pre></div></div>

<h2 id="함수의-파라미터로서의-배열">함수의 파라미터로서의 배열</h2>
<p><u>배열의이름은 포인터의 역할을 한다!</u><br />
따라서 함수 안에서 파라미터로 배열을 받아 배열의 내용을 수정하면 원래의 배열이 수정된다.<br />
배열을 매개변수로 전달할 때 배열의 길이도 전달해주어야 좋다.</p>

<p>2차워 배열을 매개변수로 보낼 때 <code class="language-plaintext highlighter-rouge">a[][5]</code>처럼 반드시 가로 값을 지정해 주어야 한다. ??
동적 할당과 이중 포인터에서 답을 찾을 수 있다!</p>]]></content><author><name>Chocobubble</name></author><category term="DS" /><category term="DS, Array" /><summary type="html"><![CDATA[C++로 쉽게 풀어쓴 자료구조 1판 - 천인국, 최영규]]></summary></entry><entry><title type="html">자료 구조 - 스택</title><link href="http://localhost:4000/ds/ds-3/" rel="alternate" type="text/html" title="자료 구조 - 스택" /><published>2023-05-27T00:00:00+09:00</published><updated>2023-05-27T00:00:00+09:00</updated><id>http://localhost:4000/ds/ds-3</id><content type="html" xml:base="http://localhost:4000/ds/ds-3/"><![CDATA[<blockquote>
  <p>‘c++로 쉽게 풀어쓴 자료구조 1판 - 천인국, 최영규’ 책을 참고하여 작성한 포스트입니다.</p>
</blockquote>

<h1 id="스택">스택</h1>
<blockquote>
  <p>스택이란 자료의 입출력이 후입선출(LIFO:Last-In First-Out)의 형태로 일어나는 자료구조를 말한다.</p>
</blockquote>

<ul>
  <li>스택 상단(stack top): 스택에서 입출력이 이루어지는 부분</li>
  <li>스택 하단(stack bottom): top의 반대 부분</li>
  <li>요소(element): 스택에 저장되는 것, 항목</li>
  <li>공백(empty)상태: 스택에 요소가 하나도 없는 상태</li>
  <li>포화(full)상태: 스택에 더 이상 요소를 넣을 수 없는 상태</li>
</ul>

<h3 id="스택의-추상-자료형">스택의 추상 자료형</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>데이터: 후입선출의 접근 방법을 유지하는 요소들의 모음
연산
 - push(x): 주어진 요소x를 스택의 맨 위에 추가
 - pop(): 스택이 비어있지 않으면 맨 위에 있는 요소를 삭제하고 반환
 - isEmpty(): 스택이 비어있으면 true, 그렇지 않으면 false 반환
 - peek(): 스택이 비어있지 않으면 맨 위에 있는 요소를 삭제하지 않고 반환
 - isFull(): 스택이 가득 차 있으면 true, 그렇지 않으면 false 반환
 - size(): 스택 내의 모든 요소들의 개수를 반환
 - display(): 스택 내의 모든 요소들을 출력함
</code></pre></div></div>

<hr />
<h1 id="스택의-구현">스택의 구현</h1>
<ul>
  <li>스택의 구현 방법으로 배열 혹은 연결 리스트를 사용할 수 있다.</li>
  <li>여기선 배열로 구현하고 연결 리스트는 나중에!
    <h2 id="배열을-이용한-스택의-표현">배열을 이용한 스택의 표현</h2>
    <p>배열은 순차적인 메모리 공간에 할당된다고 해서 순차적 표현(sequential representation)이라고도 한다. 배열은 같은 자료형의 변수를 여러 개 만드는 경우에 특히 유용하고, 항목을 저장할 수 있는 여러 개의 공간을 제공한다. 각 공간은 정확히 하나의 항목만을 담으며 각 항목들은 인덱스 번호를 통해 직접 접근이 가능하다. 인덱스 번호는 0부터 시작한다.</p>
  </li>
</ul>

<blockquote>
  <p>직접 구현해서 책과 내용이 다를 수 있습니다</p>
</blockquote>

<h3 id="구현-전">구현 전!</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 스택의 상단을 나타내는 인덱스</span>
<span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// 스택을 구현할 배열의 사이즈</span>
<span class="kt">int</span> <span class="n">MAX_STACK_SIZE</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="c1">// 스택을 구현할 배열</span>
<span class="kt">int</span> <span class="n">stack</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="c1">// 에러 처리를 메세지 출력으로 대신함</span>
<span class="kt">void</span> <span class="nf">printErrorMSG</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="pushx-연산">push(x) 연산</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">top</span> <span class="o">==</span> <span class="n">MAX_STACK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printErrorMSG</span><span class="p">(</span><span class="s">"overflow"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//비어 있는 배열의 자리로 top 인덱스를 옮기고</span>
        <span class="c1">//그 위치에 x를 대입</span>
        <span class="n">stack</span><span class="p">[</span><span class="o">++</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span> 
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pop-연산">pop() 연산</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">top</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 스택이 비어 있는 경우</span>
        <span class="n">printErrorMSG</span><span class="p">(</span><span class="s">"Stack is empty!"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//스택의 상단을 가리키는 원소 반환 후</span>
        <span class="c1">//top 인덱스를 1만큼 감소</span>
        <span class="k">return</span> <span class="n">stack</span><span class="p">[</span><span class="n">top</span><span class="o">--</span><span class="p">];</span> 
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="isempty-연산">isEmpty() 연산</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 비어 있을 때(초기화한 경우도 마찬가지)</span>
    <span class="c1">// 스택 상단의 인덱스는 -1로 정의했다</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">top</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="peek-연산">peek() 연산</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">peek</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">top</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 스택이 비어 있는 경우</span>
        <span class="n">printErrorMSG</span><span class="p">(</span><span class="s">"Stack is empty!"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 스택 상단의 원소 반환</span>
        <span class="k">return</span> <span class="n">stack</span><span class="p">[</span><span class="n">top</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="isfull-연산">isFull() 연산</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">isFull</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">top</span> <span class="o">==</span> <span class="n">MAX_STACK_SIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="size-연산">size() 연산</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 배열의 인덱스는 0에서 시작하므로</span>
    <span class="k">return</span> <span class="n">top</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="display-연산">display() 연산</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">display</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">top</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"stack의 %d번째 요소는 %d입니다.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">stack</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Chocobubble</name></author><category term="DS" /><category term="DS, Stack" /><summary type="html"><![CDATA[C++로 쉽게 풀어쓴 자료구조 1판 - 천인국, 최영규]]></summary></entry><entry><title type="html">자료 구조 - 큐</title><link href="http://localhost:4000/ds/ds-4/" rel="alternate" type="text/html" title="자료 구조 - 큐" /><published>2023-05-27T00:00:00+09:00</published><updated>2023-05-29T00:00:00+09:00</updated><id>http://localhost:4000/ds/ds-4</id><content type="html" xml:base="http://localhost:4000/ds/ds-4/"><![CDATA[<blockquote>
  <p>‘c++로 쉽게 풀어쓴 자료구조 1판 - 천인국, 최영규’ 책을 참고하여 작성한 포스트입니다.</p>
</blockquote>

<h1 id="큐queue">큐(Queue)</h1>
<ul>
  <li>큐는 자료의 입출력이 선입선출(FIFO: First-In First-Out)의 형태로 일어나는 자료구조를 말한다.</li>
  <li>큐에서 삽입이 일어나는 곳을 후단(rear)이라고 하고 삭제가 일어나는 곳을 전단(front)라고 한다.</li>
</ul>

<h2 id="큐의-추상-자료형">큐의 추상 자료형</h2>
<p>스택과 유사하다</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>데이터: 선입선출의 접근 방법을 유지하는 요소들의 모음
연산
 - enqueue(e): 주어진 요소 e를 큐의 맨 앞에 추가
 - dequeue(): 큐가 비어 있지 않으면 맨 앞에 있는 요소를 삭제하고 반환
 - isEmpty(): 큐가 비어 있으면 true, 그렇지 않으면 false 반환
 - peek(): 큐가 비어있지 않으면 맨 앞에 있는 요소를 삭제하지 않고 반환
 - isFull(): 큐가 가득 차 있으면 true, 그렇지 않으면 false 반환
 - size(): 큐 내의 모든 요소들의 개수를 반환
 - display(): 큐 내의 모든 요소들을 출력함
</code></pre></div></div>

<h2 id="큐의-활용">큐의 활용</h2>
<p>컴퓨터 장치들 사이에서 데이터를 주고받을 때 각 장치들 사이에 존재하는 속도의 차이나 시간 차이를 극복하기 위한 임시 기억 장치로 큐가 사용되는데, 이것을 보통 버퍼(buffer)라고 부른다.</p>

<h2 id="큐의-구현">큐의 구현</h2>
<ul>
  <li>선형 큐 : front와 rear의 값이 계속 증가하므로 언젠가는 배열의 끝에 도달하게 되어 더 이상 삽입하지 못하게 된다. 이 때 모든 요소들을 왼쪽으로 이동시켜야 하는데 그러면 삽입 연산의 시간 복잡도가 $O(n)$이 된다.</li>
  <li>원형 큐 : 배열이 원형처럼 처음과 끝이 연결되어 있다고 가정한 큐이다. 배열의 끝에 도달하면 가리키는 인덱스를 0으로 바꾸어주면 된다. 그러면 배열이 포화되지 않는 이상 삽입과 큐는 끝없이 이루어질 수 있다.</li>
</ul>

<hr />

<h3 id="원형-큐의-구현">원형 큐의 구현</h3>

<details>
<summary>큐 구현 코드</summary>
<div>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
#define MAX_QUEUE_SIZE 100
</span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">printErrorMSG</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">CircularQueue</span> <span class="p">{</span>
<span class="nl">protected:</span>
    <span class="kt">int</span> <span class="n">front</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rear</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">queue</span><span class="p">[</span><span class="n">MAX_QUEUE_SIZE</span><span class="p">];</span>
<span class="nl">public:</span>
    <span class="n">CircularQueue</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">front</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">rear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">front</span> <span class="o">==</span> <span class="n">rear</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">isFull</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">front</span> <span class="o">==</span> <span class="p">(</span><span class="n">rear</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">MAX_QUEUE_SIZE</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">isFull</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">printErrorMSG</span><span class="p">(</span><span class="s">"queue is full"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">queue</span><span class="p">[</span><span class="n">rear</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
            <span class="n">rear</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">dequeue</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">printErrorMSG</span><span class="p">(</span><span class="s">"queue is empty"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="n">front</span><span class="p">];</span>
            <span class="n">front</span> <span class="o">=</span> <span class="p">(</span><span class="n">front</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">MAX_QUEUE_SIZE</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">peek</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">printErrorMSG</span><span class="p">(</span><span class="s">"queue is empty"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">queue</span><span class="p">[</span><span class="n">front</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">front</span> <span class="o">&gt;</span> <span class="n">rear</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">8</span> <span class="o">-</span> <span class="n">front</span> <span class="o">+</span> <span class="n">rear</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">rear</span> <span class="o">-</span> <span class="n">front</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">display</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">front</span> <span class="o">&gt;</span> <span class="n">rear</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">front</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_QUEUE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">rear</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">front</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">rear</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </div>
</details>

<h3 id="연결리스트로-구현한-큐">연결리스트로 구현한 큐</h3>
<p>원형 배열로 구현한 큐도 스택과 같이 크기가 제한된다는 약점이 있다. 연결리스트를 이용하면 크기 제한이 사라진다. 자세한건 연결리스트에서!</p>

<h1 id="덱deque">덱(deque)</h1>
<blockquote>
  <p>덱은 double-ended queue의 줄임말로서 큐의 전단(front)과 후단(rear)에서 모두 삽입과 삭제가 가능한 큐를 의미한다. 중간에 삽입 삭제는 x!<br />
즉, 스택과 큐의 연산들을 모두 가지고 있다고 보면 된다.</p>
</blockquote>

<h2 id="덱-추상-자료형">덱 추상 자료형</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>데이터: 전단과 후단을 통한 접근을 허용하는 요소들의 모음
연산
 - addFront(e): 주어진 요소 e를 덱의 맨 앞에 추가
 - deleteFront(): 덱이 비어 있지 않으면 맨 앞 요소를 삭제하고 반환
 - addRear(e): 주어진 요소 e를 덱의 맨 뒤에 추가
 - deleteRear(): 덱이 비어 있지 않으면 맨 뒤 요소를 삭제하고 반환
 - isEmpty(): 덱이 비어 있으면 true, 그렇지 않으면 false 반환
 - getFront(): 덱이 비어있지 않으면 맨 앞 요소를 삭제하지 않고 반환
 - getRear(): 덱이 비어있지 않으면 맨 뒤 요소를 삭제하지 않고 반환
 - isFull(): 덱이 가득 차 있으면 true, 그렇지 않으면 false 반환
 - display(): 덱 내의 모든 요소들을 출력함
</code></pre></div></div>
<h2 id="덱의-구현">덱의 구현</h2>
<ul>
  <li>덱도 원형 큐에서와 같이 배열을 이용하는 방법과 연결 리스트를 사용하는 방법이 있다.</li>
</ul>

<h3 id="배열을-이용한-원형-덱의-구현">배열을 이용한 원형 덱의 구현</h3>
<p>앞서 구현한 원형 큐 클래스를 상속받아 구현한다.</p>

<h3 id="원형-큐의-구현-1">원형 큐의 구현</h3>

<details>
<summary>덱 구현 코드</summary>
<div>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 앞서 만든 큐 클래스</span>
<span class="cp">#include</span> <span class="cpf">"CircularQueue.h"</span><span class="c1">  </span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">CircularDeque</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CircularQueue</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">CircularDeque</span><span class="p">()</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="nf">addRear</span> <span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 큐와 동일한 연산</span>
        <span class="n">enqueue</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> 
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">deleteFront</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 큐와 동일한 연산</span>
        <span class="k">return</span> <span class="n">dequeue</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">getFront</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 큐와 동일한 연산</span>
        <span class="k">return</span> <span class="n">peek</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">addFront</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">isFull</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">printErrorMSG</span><span class="p">(</span><span class="s">"deque is full"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">queue</span><span class="p">[</span><span class="n">front</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
            <span class="n">front</span> <span class="o">=</span> <span class="p">(</span><span class="n">front</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_QUEUE_SIZE</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">deleteRear</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">printErrorMSG</span><span class="p">(</span><span class="s">"deque is empty"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="n">rear</span><span class="p">];</span>
            <span class="n">rear</span> <span class="o">=</span> <span class="p">(</span><span class="n">rear</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">MAX_QUEUE_SIZE</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_QUEUE_SIZE</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">getRear</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">printErrorMSG</span><span class="p">(</span><span class="s">"deque is empty"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">queue</span><span class="p">[</span><span class="n">rear</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">display</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"덱의 요소들: "</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">front</span> <span class="o">&lt;</span> <span class="n">rear</span><span class="p">)</span> <span class="o">?</span> <span class="n">rear</span> <span class="o">:</span> <span class="n">rear</span><span class="o">+</span><span class="n">MAX_QUEUE_SIZE</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">front</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">lentgh</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">queue</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">MAX_QUEUE_SIZE</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>

  </div>
</details>

<h3 id="연결된-덱의-구현">연결된 덱의 구현</h3>
<p>덱은 스택이나 큐와 달리 전단과 후단에서 모두 삽입, 삭제가 가능하므로 이중 연결 리스트를 이용해 구현해야 한다.</p>]]></content><author><name>Chocobubble</name></author><category term="DS" /><category term="DS, Queue" /><summary type="html"><![CDATA[C++로 쉽게 풀어쓴 자료구조 1판 - 천인국, 최영규]]></summary></entry><entry><title type="html">자료 구조 - 시작</title><link href="http://localhost:4000/ds/ds-1/" rel="alternate" type="text/html" title="자료 구조 - 시작" /><published>2023-05-26T00:00:00+09:00</published><updated>2023-05-28T00:00:00+09:00</updated><id>http://localhost:4000/ds/ds-1</id><content type="html" xml:base="http://localhost:4000/ds/ds-1/"><![CDATA[<blockquote>
  <p>‘c++로 쉽게 풀어쓴 자료구조 1판 - 천인국, 최영규’ 책을 참고하여 작성한 포스트입니다.</p>
</blockquote>

<h1 id="자료구조">자료구조</h1>
<h3 id="자료구조란">자료구조란?</h3>
<ul>
  <li>자료들을 편리하고 효율적으로 처리하기 위해 정리하고 조직화하는 구조이다.</li>
</ul>

<h2 id="자료구조의-분류">자료구조의 분류</h2>
<p>자료구조는 단순 자료구조와 여러 가지 자료들이 복합적으로 구성된 복합 자료구조로 나눌 수 있다.</p>
<ul>
  <li>단순 자료구조 : 정수, 실수, 문자, 문자열, 포인터 같이 많은 프로그래밍 언어에서 기본적으로 제공하는 단순 자료구조</li>
  <li>복합 자료구조 : 여러 가지 자료들이 복합적으로 구성된 자료구조이며, 선형 구조와 비선형 구조로 나눌 수 있다.</li>
</ul>

<h3 id="선형-자료구조linear-data-structure">선형 자료구조(linear data structure)</h3>
<ul>
  <li>선형 자료구조는 기본적으로 자료들이 순서적으로 나열된다. 배열, 연결 리스트, 스택, 큐, 덱 등이 이에 해당한다. 접근하는 방법으로 <strong>순서 접근(sequential access)</strong>과 <strong>직접 접근(direct access)</strong> 방법으로 나눌 수 있다. 대표적인 직접 접근 방법으로 배열이 있으며, 순서 접근 방법으로는 연결 리스트가 있다</li>
</ul>

<h3 id="비선형-자료구조non-linear-data-structure">비선형 자료구조(non-linear data structure)</h3>
<ul>
  <li>자료들 간에 선형적인 순서가 있는 것이 아니라 보다 복잡한 연결을 갖는 형태로 트리와 그래프 등이 여기에 속한다.</li>
</ul>

<h2 id="자료구조의-활용">자료구조의 활용</h2>
<ul>
  <li>컴퓨터에서 다양한 자료구조를 활용하는 대표적인 사례가 정렬과 탐색이다. 정렬은 주어진 자료들을 어떤 기준을 바탕으로 순서대로 나열한다. 효율적인 정렬을 위해 다양한 자료구조의 활용이 필요하다. 적절한 자료구조와 그에 따른 알고리즘을 사용하는 경우 효율적인 탐색이 가능하다.</li>
</ul>

<hr />

<h1 id="알고리즘algorithm">알고리즘(algorithm)</h1>
<p>어떤 문제를 해결하는 절차. 컴퓨터에선 주어진 상태에서 문제를 해결하는 방법을 장치가 이해할 수 있는 언어로 정밀하게 기술한 것이다. 즉, 특정한 일을 수행하는 명령어들의 집합이다.</p>
<h3 id="알고리즘의-조건">알고리즘의 조건</h3>
<ol>
  <li>입  력 : 0개의 이상의 입력이 존재해야 한다.</li>
  <li>출  력 : 1개 이상의 출력이 존재해야 한다.</li>
  <li>명백성: 각 명령어의 의미는 모호하지 않고 명확해야 한다.</li>
  <li>유한성: 한정된 수의 단계 후에는 반드시 종료되어야 한다.</li>
  <li>유효성: 각 명령어들은 실행 가능한 연산이어야 한다.</li>
</ol>

<hr />
<h1 id="추상-자료형">추상 자료형</h1>
<h3 id="추상화란">추상화란?</h3>
<p>복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념이나 기능을 간추려 내는 것을 말한다. 시스템의 핵심적인 구조나 동작에만 집중하는 것이다.<br />
좋은 추상화는 사용자에게 중요한 정보는 강조되고 그렇지 않은 세부 사항은 제거되는 것이다.</p>

<h3 id="추상-자료형adt-abstract-data-type">추상 자료형(ADT: Abstract Data Type)</h3>
<p>자료의 집합과 자료에 가해지는 연산들을 정의하는 것이다. 자료의 구체적인 표현을 숨겨 프로그래머가 자료의 구조와 연산에만 집중할 수 있도록 하여 프로그램의 구조를 단순화하고 이해하기 쉽게 한다.</p>

<p>추상 자료형을 표현할 때는 먼저 데이터를 정의하고, 다음으로 연산들을 정의한다. 데이터는 주로 집합의 개념을 사용하여 표현하고, 연산의 정의에는 연산의 이름, 매개변수, 연산의 결과, 연산이 수행하는 기능 등을 기술한다.</p>

<p>간단한 인터페이스(interface)만 제공함으로써 구현에 관한 세부사항들은 외부에서 모르게 한다. 추후에 구현 방법이 변경되더라도 인터페이스만 정확하게 지켜진다면 사용자는 변경된 내용을 알 필요도 없고 사용하는데 문제도 없다.</p>

<p>‘구현으로부터 명세의 분리’가 추상 자료형의 중심 아이디어다.</p>

<h3 id="추상자료형과-c">추상자료형과 c++</h3>
<ul>
  <li>추상 자료형에서의 데이터는 클래스의 속성(멤버 변수)으로 구현되고 연산은 클래스의 메소드(멤버 함수)로 구현된다.</li>
  <li><code class="language-plaintext highlighter-rouge">private</code>나 <code class="language-plaintext highlighter-rouge">protected</code> 키워드를 통해 접근을 제한할 수 있다.</li>
</ul>

<hr />
<h1 id="알고리즘의-성능-분석">알고리즘의 성능 분석</h1>

<ul>
  <li>효율적인 알고리즘이란 전체 실행 시간이 짧으면서 메모리와 같은 컴퓨터의 자원들을 적게 사용하는 알고리즘이다. 일반적으로 실행 시간이 메모리 공간보다 더 중요하게 생각된다. 시간 복잡도가 알고리즘의 성능에 더 큰 영향을 미치기 때문이다.</li>
</ul>

<h3 id="알고리즘의-복잡도-분석-방법">알고리즘의 복잡도 분석 방법</h3>
<p>알고리즘을 직접 구현하지 않고 대략적인 효율성을 분석하는 방법이다. 실행 하드웨어나 소프트웨어 환경과는 관계없이 알고리즘의 효율성을 평가할 수 있다.</p>

<p>알고리즘의 실행 시간 분석을 시간 복잡도(time complexity)라고 하고, 알고리즘이 사용하는 기억 공간 분석을 공간 복잡도라고 한다.</p>

<p>일반적으로 알고리즘의 복잡도는 대개 시간 복잡도를 얘기하므로 시간 복잡도에 집중하여 정리하겠다.</p>

<h3 id="빅오-표기법">빅오 표기법</h3>
<p>일반적으로 시간 복잡도 함수 $T(n)$은 입력의 개수 $ n$ 에 대한 상당한 복잡한 수식으로 나타날 수 있다. 그러나 n이 커질수록 차수가 가장 큰 영향이 절대적이 되고 다른 항들은 무시될 수 있을 정도로 작아진다.</p>

<p>시간 복잡도 함수에서 중요한 것은 $ n$이 증가함에 따라 무엇에 비례하는 수의 연산이 필요한가 이다.</p>

<p>시간 복잡도 함수에서 불필요한 정보를 제거하여 알고리즘 분석을 쉽게 할 목적으로 시간 복잡도를 표시하는 방법을 빅오 표기법이라 한다.</p>

<blockquote>
  <h3 id="빅오표기법">빅오표기법</h3>
  <p>두 개의 함수 $ f(n) $과 $ g(n) $이 주어졌을 때 모든 $ n &gt; n_0 $ 대하여 $ |f(n)|&lt;=c|g(n)|$을 만족하는 상수$ c$와 $ n_0$가 존재하면 $ f(n) = O(g(n))$이다.</p>
</blockquote>

<p>빅오 표기법을 얻는 간단한 방법은 다항식의 최고차항만을 남기고 다른 항들과 상수항을 버리는 것이다. 최고차항의 계수도 버리면 된다.</p>

<p>빅세타, 빅오메가도 있다. 빅세타는 알고리즘의 평균적인 경우 시간 복잡도이며, 빅오메가는 최선의 경우 시간 복잡도이다.</p>

<p>평균적인 실행시간이 가장 좋아 보이지만 계산하기 어려운 경우가 많으며, 최악의 상황에 대한 시간을 보장하지 못한다는 점에서 문제가 있어 빅오 표기법을 주로 사용한다.</p>

<hr />
<p># 문제</p>]]></content><author><name>Chocobubble</name></author><category term="DS" /><category term="DS" /><summary type="html"><![CDATA[C++로 쉽게 풀어쓴 자료구조 1판 - 천인국, 최영규]]></summary></entry><entry><title type="html">DS Test 1</title><link href="http://localhost:4000/ds/ds-test/" rel="alternate" type="text/html" title="DS Test 1" /><published>2023-05-26T00:00:00+09:00</published><updated>2023-05-26T00:00:00+09:00</updated><id>http://localhost:4000/ds/ds-test-</id><content type="html" xml:base="http://localhost:4000/ds/ds-test/"><![CDATA[<h1 id="for-test">For Test</h1>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Hello"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>1</p>
</blockquote>

<p>This <strong>post</strong> is <em>for</em> testing.</p>

<p>And and and <u>and</u></p>
<ul>
  <li>111</li>
  <li>222</li>
</ul>

<ol>
  <li>111</li>
  <li>222</li>
</ol>]]></content><author><name>Chocobubble</name></author><category term="DS" /><category term="ds" /><summary type="html"><![CDATA[For Test int main() { cout&lt;&lt;"Hello"; } 1 This post is for testing. And and and and 111 222 111 222]]></summary></entry><entry><title type="html">Post:Sample Test</title><link href="http://localhost:4000/test/test-post/" rel="alternate" type="text/html" title="Post:Sample Test" /><published>2023-05-25T00:00:00+09:00</published><updated>2023-05-25T00:00:00+09:00</updated><id>http://localhost:4000/test/test-post</id><content type="html" xml:base="http://localhost:4000/test/test-post/"><![CDATA[<h1 id="for-test">For Test</h1>

<blockquote>
  <p>1</p>
</blockquote>

<p>This post is for testing.</p>]]></content><author><name>Chocobubble</name></author><category term="Test" /><category term="test" /><summary type="html"><![CDATA[For Test 1 This post is for testing.]]></summary></entry></feed>