---
title:  "[Graphics] 개요"
excerpt: "DirectX 11"
excerpt_separator: "<!--more-->"
categories:
  - Graphics
tags:
  - Graphics

toc: true
toc_sticky: true

use_math: true

date: 2023-09-21
last_modified_at: 2023-09-21
---

> 출처 : 홍정모의 컴퓨터 그래픽스 새싹코스

# dx11, ImGUI 개요
- d3.compiler.h
	- VS.hlsl, PS.hjsl 컴파일에 사용

- uv
	- texture coordinates
	- 2차원


- othographic projection
- perspective projection



# Phong Model vs Phong Shading
## Phong Reflection Model
- 조명 받았을 떄
- ambient + diffuse + specular 로 표현

### ambient
- ambient color
- 조명이 없어도 나타남

### diffuse
- 조명과 충돌 지점의 normal vector의 각도에 따라 diffuse 결정
- cos을 이용하는데, unit vector인 경우 dot product로 계산 가능하다.
- 90도가 넘어가면 0으로 고정해주어야함

### specular
- 조명이 반사될 때, 반사벡터와 시점의 각도에 따라 specular 결정
- 반사 벡터를 구하고, 시점으로 향하는 벡터와 cos 이용하여 계산, 이 또한 unit vector를 이용해 dot product로 계산 가능하다.
- pow를 이용해 빛이 집중 되는 정도를 조절할 수 있다.


## Phong Shading
- Phong Model 실제 구현 시 픽셀 단위의 normal vector를 이용해 쉐이딩 하는 것



# winding order
- 삼각형의 vertex를 나열하는 순서.
- clockwise를 CW, counter clockwise를 CCW라 부른다.
- 특정 삼각형 안의 점은 삼각형의 세 vertex와 선을 이어 삼각형을 세개 그렸을 때, 세 삼각형의 외적도 같은 방향임.
- 삼각형 밖의 점은 위의 세 삼각형 중 하나를 뒤집은 느낌



# 원근 투영
- 왜곡이 생기는 이유
	-  interpolation 이 poject 된 screen 상에서 계산되므로 pixel 위치에서 계산한 것과 다르다.
- 해결 방법
	- 제타(시점과 vertex의 z축 위에서의 거리)를 이용해 보정


# 블린-퐁 쉐이딩
- 쉐이딩이란 조명과 재질의 상호작용을 고려해 색을 결정하는 과정
- 쉐이딩은 vertex에서 할 수 도 있고 pixel에서도 할 수 있다. 
	- vertext의 수가 훨씬 적기 때문에 vertex shading이 더 빠르다.
		- 하지만 상세도가 낮겠죠
- 반사 벡터는 계산이 오래 걸리므로 Halfway Vector와, normal vector를 이용해 퐁 쉐이딩을 개선한 쉐이딩
	- halfway vector는 빛 벡터와 시야 벡터의 half vector
	- halfway vector 와 normal vector를 dot product한 값을 이용한다.

## light strength
- 빛의 각도와 normal 벡터를 이용해 빛의 각도 계산

## diffuse Reflection

## specular Reflection
- 특정 방향으로 빛을 강하게 반사.
- halfway 와 normal을 내적한 값을 shiness 만큼 pow한 결과 값

## shiness
- 빛이 집중되는 정도

## 결과
- ambient + (diffuse + specular) * lightStr;


# 조명
- directional light, point light, spotlight 등이 있다.

## point light
- 포인트로 부터 멀어질 수록 빛의 세기가 감소한다.
- linear 하게 falloffstart -> fallofend(여기선 빛의 세기가 0) 해주면 된다.

# wire frame
- 삼각형의 변만 보여준다
- backface culling도 가능

# normal vector 그리기
- DirectX 에는 normal vector 그려주는 메서드 없다.
- D3D11_PRIMITIVE_TOPOLOGY_LINELIST
	- 선분을 그릴 때 사용
- 한 화면에 겹쳐 그릴때는 ClearRenderTargetView, ClearDepthStencilView, SetViewport, SetRenderTarget, SetDepthStencilState 등은 한번만 해주는 것이 맞다..
- BasicVertexConstantBuffer에 이미 행렬들이 들어가 있는 부분들은 제외하고 NormalVertexConstantBuffer를 만들어 넣어주면 된다.
	- 그럼 Update에서도 행렬들을 이용한 계산을 중복해서 하지 않아도 된다.
	- shader 에서도 맞춰서 수정해주어야함
- 변화가 있을 때만 업데이트 해주도록 최적화 할 수도 있겠죠
- flag를 이용해 update 부분은 Update에 몰아주는 것이 관리하기 좋다.

# 격자 평면
- 지형, 실린더, 구 모형 등 구현 시 유용한 모델링 기술

# 실린더
- 원형인 경우 텍스처의 좌표 0~1을 맞춰주기 위해 시작점의 vertex는 두개로 해주어야 한다.

# subdivision
- 해상도가 낮은 물체를 높은 물체로 만드는 기능
- 삼각형을 여러 삼각형으로 쪼갬
- 새로 생긴 vertex들의 포지션을 조절해주어야 함
- GPU에서 할 수 있는 기능이므로, CPU에서는 해상도가 낮게 만들어 보내 GPU에서 높게 만드는 장점


# Face vs Vertex Normals
- normal vector가 렌더링에 어떻게 영향을 미치는 지
- 같은 위치여도 vertex가 여러개이면, normal vector가 여러개 일 것이고,,
	- 각져있게된다?

# 구 매핑
- subdivision 하다보면 텍스쳐 이음매가 깔끔하지 않음..
- 맞닿는 부분의 삼각형의 vertex 의 texture 좌표가 (0,0), (1,0) 이렇게 되는 경우 깨질 수 있다.
- pixel 쉐이더를 이용하면 해결 가능

# 3차원 모델 파일 읽기
- 언리얼에서는 FBX를 주로 사용
- assimp:x64-windows

vcpkg install assimp:x64-windows
vcpkg install directxtk:x64-windows
vcpkg install directxtex[openexr]:x64-windows
vcpkg install directxmath:x64-windows
vcpkg install fp16:x64-windows
vcpkg install imgui[dx11-binding,win32-binding]:x64-windows
vcpkg install glm:x64-windows
vcpkg install directxmesh:x64-windows
vcpkg install eigen3:x64-windows (파트4)
vcpkg install physx:x64-windows <- PHYSX 물리 엔진 (파트4)

# Rim 효과
- 물체의 테두리에 역광 효과
- 가장자리를 먼저 찾아야 겠죠.
	- 시야와 normal vector의 각도가 90가 되는 점이 눈에 보이는 가장자리이다.
	- dot product 이용.,.

# 큐브 매핑



# 피킹 광선 충돌
- BoundingSphere
## 자유도
- Degrees of Freedom (DOF)
- 3차원 공간의 회전의 자유도는 3자유도이다.

## 오일러 각도
- 3차원의 회전을 세개의 각도로 표현
- 3x3 회전행렬들의 곱으로 계산

## 짐벌락
- 두 축이 겹쳐지면 자유도를 하나 잃어버림
- 수식으로 찾아보자.
- 두 축이 겹쳐졌을 때 겹쳐진 두 벡터의 외적은 0벡터이다.
- 그래서 예전 게임의 경우 두 축이 겹칠때 막 회전하는 오류가 발생하기도 했다.

## 쿼터니언
- Quaternion(사원수)
- 3차원 회전을 4개의 수로 표현한다.
	- 짐벌락 방지
	- 숫자가 네개지만 합의 절댓값이 1이어야하는 제약이 있어 3자유도가 되어 3차원 회전을 표현하게된다.
- 회전 행렬과 호환되며, 회전의 보간(interpolation)에 유리하다.

### 쿼터니언 회전 방법
- 벡터 v를 	n 축에 대해 theta 만큼 	회전시킨다면,
- v를 쿼터니언으로 먼저 만들고
	-  p = Quaternion(v, 0)
- 회전을 위한 q = Quaternion(nsin(theta/2), cos(theta/2))과 이 Quaternion의 conjugate Quaternion인 q*를 만든다.
- qpq* 를 계산하면 된다.

### 쿼터니언의 구성
- q = xi + yj + zk + w 
	- i, j, k는 허수, w는 실수이다.
	- 허수와 실수를 묶어 간단히 벡터처럼 (u, w) 로 표현하기도 한다.
		- 가로축을 실수, 세로축을 허수로 두는 등 2차원에 표현 가능해짐
			- q = 1 -> q = i 가 되면 즉, i를 곱하면 실수축에서 허수축으로 90도만큼 회전 효과가 일어난 것으로 볼 수 있다.
	- i, j, k는 각각 제곱하면 -1이다.
	- 두 허수의 곱은 나머지 한 허수와 같고, 또한 두 허수를 뒤집어 곱한 값에 -를 곱한 값과 같다.
		- ij = k = -ji

### 쿼터니언의 연산
- +, -는 각각의 원소끼리 +, -
- 곱하기는 다항식의 곱으로 보면 된다.
- q1(u1, w1) * q2(u2, w2) 를 잘 정리해보면,
	- (w1u2 + w2u1 + u1Xu2, w1w2 - u1*u2) 로 외적과 내적으로 표현 가능하다.

### 절댓값
- $x^2 + y^2 + z^2 + w^2$ 를 루트씌워준 값.

### Conjugate
- q(u, w) 의 conjugate Quaternion 은 q*(-u, w)

### Inverse
- q(u, w) 의 Inverse Quaternion 은..
	- 먼저 q와 q\*의 곱은 q나 q\*의 절댓값과 같다.
	- 이를 이용하면 $q^{-1}$ = q* / (q의절댓값)  이라 볼 수 있다.
		- q의 절댓값이 1이라면 Inverse Quaternion은 Conjugate Quaternion 이 되겠죠  

![Image](https://github.com/chocobubble/Test/assets/100405650/8df2c5ef-7e6d-469f-869b-2ed64b8daa2a)

# MVP
- model , view, projection?
	1. model coordinates를 model matrix(혹은 world matrix)를 통해 world coordinates로 변환
	2. world coordinates를 view matrix를 통해 camera coordinates로 변환
	3. camera coordinates를 projection matrix를 통해 Homogeneous coordinates로 변환

# 가상 트랙볼
- 물체의 bounding sphere를 회전시킨다고 보면 된다.
- 한 지점에서 다른 지점으로 회전시킨다고 할때 회전 축은 두 지점 벡터의 cross product 결과겠죠
- 각도는 두 벡터를 normalize하고 dot product를 통해 구하면 된다.

# 드래그로 이동시키기
- 

# 참고
- Introduction to 3D Game programming with DX12 - Luna

# 주의
- 회전 시킬 때 normal vector도 회전시켜주어야 한다.

