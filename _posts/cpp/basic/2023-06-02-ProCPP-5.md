---
title:  "[전문가를 위한 C++] 객체지향 설계"
excerpt: "전문가를 위한 C++"
excerpt_separator: "<!--more-->"
categories:
  - CPP
tags:
  - CPP
  - OOP

toc: true
toc_sticky: true

use_math: true

date: 2023-07-02
last_modified_at: 2023-07-02
---

> '전문가를 위한 C++ - Marc Gregoire 지음, 남기혁 옮김' 책을 참고하여 작성한 포스트입니다.

---

# 절차형 사고방식
- c와 같은 절차형 언어는 단 하나의 작업만 담당하는 procedure라 부르는 작은 단위로 코드를 구성한다.
- procedure는 프로그래머가 코드를 읽고 관리하기 쉽도록 추상화한 것이다.
- 프로시저는 **프로그램이 하는 일**을 중심으로 만든 개념이다. 그래서 프로그램이 하는 일을 정리해보면 자연스레 절차적으로 표현된다.
- 절차형 접근 방식은 일정한 단계에 따라 진행하는 프로그램에 적합하다.

# 객체지향 철학
- 객체지향 접근 방식은 '모델링하려는 현실 세계의 대상'이라는 관점에서 접근한다.
- 객체지향 프로그래밍(Object-Oriented Programming, OOP)은 프로그램을 작업(task) 단위가 아니라 실제 대상에 대한 모델 단위로 구성한다.

## 클래스(class)
- 클래스는 어떤 대상의 유형을 정의하는 속성을 정리한 것이다.
- 특정 구체적인 대상을 객체라고 한다. 객체는 어떤 클래스에 속하는 구체적인 예(instance)이다.
- 오렌지라는 과일의 한 종류를 클래스라고 하고, 특정 오렌지를 객체라고 보면 된다.

## 컴포넌트(component)
- 현실에 존재하는 대상들은 작은 부품(component)로 구성되어 있다.
- OOP에서는 객체를 작은 컴포넌트 단위로 나누는 사고방식이 중요하다.
- 컴포넌트로 나눠 관리하기 쉽게 한다.

## 속성
- 객체는 속성(property)로 구분한다.
- 속성은 객체의 특성을 표현하므로 객체끼리 구분하게 해준다.
- 클래스 속성의 값은 그 클래스에 속한 모든 객체에서 똑같지만 객체 속성의 값은 그 클래스에 속한 객체마다 다를 수 있다.
- 오렌지를 구성하는 속성의 종류는 같지만 그 값은 오렌지마다 다르다. 어떤 오렌지는 맛이 있을 수 있고 어떤 오렌지는 별로 맛이 없을 수도 있다. 색깔도 조금씩 다를 수 있고.


## 동작
- 동작(behavior)은 객체가 직접 하거나 그 객체로 할 수 있는 일을 표현한다.
- OOP에서는 어떤 기능을 수행하는 코드를 프로시저가 아닌 클래스 단위로 묶는다.
- 클래스가 여러 가지 동작을 수행하고, 서로 상호 작용하는 방식을 정의함으로써 데이터를 조작하는 코드를 훨씬 다양하게 제공 가능하다.
- 클래스의 동작은 메서드(method)로 구현한다.


# 클래스 관계
- 서로 다른 클래스가 공통적인 속성을 가지거나, 최소 두 개가 관련된 경우가 있다.
- 이런 클래스 관계에는 **has-a 관계**와 **is-a 관계** 가 있다.

## has-a 관계
- A는 B를 가진다. A에 B가 있다. 등 한 클래스가 다른 클래스의 일부인 관계이다.
- 두 가지 유형이 있다.
    - 집계(aggregation)
        - 집계된 객체는 집계를 수행한 대상이 제거되더라도 남아 있다.
    - 합성(composition)
        - 여러 객체로 구성된 객체가 제거되면 포함된 객체도 함께 사라진다.

## is-a 관계(상속)
- OOP의 핵심 개념.
- 파생(deriving), 서브클래싱(subclassing). 확장(extending), 상속(inheriting) 등으로 불린다.
- A 는 일종의  B다. A는 B를 상당히 많이 닮았다. 등으로 표현한다.
- 클래스를 is-a 관계로 엮으려면 공통 기능을 **베이스 클래스(base class, 상위 클래스)**로 묶어 다른 클래스가 확장할 수 있게 해야 한다.
- 여러 클래스의 코드가 겹치거나 똑같다면 그 부분을 상위 클래스로 묶어서 빼내는 것이 좋다. 그러면 상위 클래스만 수정해도 하위 클래스들 모두를 수정하는 효과가 있다.

### 상속 기법
- 파생(하위) 클래스는 아래 기법들 중 한 개 이상을 조합해 만든다.
1. 기능 추가
    - 기능을 추가해 부모 클래스를 확장
2. 기능 변경
    - 부모 클래스가 가진 메서드를 변경하거나 무시(override) 할 수 있다.
    - 상위 클래스에 있는 속성과 메서드를 모두 바꿔야 한다는 것은 상위 클래스가 **추상 클래스**가 아닌 이상 설계가 잘못 되었다는 뜻이겠죠
3. 속성 추가
    - 새로운 속성 추가 가능
4. 속성 변경
    - 속성도 오버라이드 가능하다.
    - 베이스 클래스의 속성을 가리므로 보통은 사용하지 않는 것이 좋다.
    - 베이스 클래스의 속성과 같은 이름을 정의해 다른 값을 표현할 수 있다.

### 다형성(polymorphism)
- 일정한 속성과 메서드를 표준으로 정해두면 그 형식에 맞는 객체라면 어느 것이든 서로 바꿔 적용할 수 있다는 개념이다.
- 파생 클래스들은 부모 클래스에 정의된 속성과 메서드를 모두 제공해야 한다.
- 동물원의 모든 동물들의 부모 클래스를 Animal 이라고 하면, 각 동물의 move() 오버라이딩 유무에 관계없이 Animal의 move()를 호출하면 모든 동물을 이동시킬 수 있다. 
- 객체의 상속 받은 부모가 같을 때, 서로 다른 형태를 가지고 있다고 해도 부모에게 상속받은 똑같은 함수를 호출하면 서로 다른 동작을 하게 되는 것.
- 즉 하나의 코드로 다양한 타입의 객체를 처리 가능하다.

## has-a 관계와 is-a 관계 구분하기
- LSP(Liskov Substitution Principle, 리스코프 치환 원칙)을 이용한다.
    - 동작을 바꾸지 않고도 베이스 클래스 대신 파생 클래스를 사용할 수 있어야 한다는 기준.
    - 

## not-a 관계
- 