---
title:  "[컴퓨터구조] CPU 성능 향상 기법"
excerpt: "혼공컴운"
excerpt_separator: "<!--more-->"
categories:
  - Architecture
tags:
  - Computer Architecture
  - CPU

toc: true
toc_sticky: true
 
font-family: $happiness

use_math: true

date: 2023-06-07
last_modified_at: 2023-06-08
---

> '혼자 공부하는 컴퓨터구조+운영체제 - 강민철' 책을 참고하여 작성한 포스트입니다.

---

# 클럭
- 클럭 속도가 빠르면 CPU를 포함한 컴퓨터 부품들은 그만큼 빠르게 작동할 것이고 그에 따라 일반적으로 CPU 성능이 좋다.
- 클럭 속도는 헤르츠(Hz) 단위로 측정한다. 1초에 클럭이 몇 번 반복되는지를 나타낸다.

<br>

# 코어와 멀티코어
- **코어(core)**는 CPU 내에서 명령어를 실행하는 부품..
- 코어를 여러 개 포함하는 CPU를 **멀티코어(multi-core)**CPU 또는 **멀티코어 프로세서** 라고 부른다.

<br>

# 스레드와 멀티스레드
- **스레드(thread)**는 **하드웨어적 스레드**와 **소프트웨어적 스레드**로 나눌 수 있다.

## 하드웨어적 스레드
- 스레드를 하드웨어적으로 정의하면 <u>하나의 코어가 동시에 처리하는 명령어 단위</u> 이다.
- 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 **멀티스레드(multithread)프로세서** 또는 **멀티스레드 CPU**라고 부른다.
- 인텔은 하이퍼스레딩(hyper-threading)이라고 부른다.

## 소프트웨어적 스레드
- 소프트웨어적으로 정의하면 <u>하나의 프로세스에서 독립적으로 실행되는 단위</u>이다.
- 프로그래밍 언어나 운영체제 학습 시 접하는 스레드는 보통 이렇게 정의된 스레드이다.
- 여러 기능들을 작동시키는 코드를 각각의 스레드로 만들면 <u>1코어 1스레드 CPU도 소프트웨어적 스레드를 수십 개 실행할 수 있다!</u>

## 멀티스레드 프로세서
- 소프트웨어적 스레드는 추후 운영체제에서 자세히 알아보고, 여기서는 하드웨어 스레드로 지칭해 설명한다.
- **멀티스레드 프로세서**의 핵심은 **레지스터**이다.
- 하나의 코어로 여러 명령어를 동시에 처리하도록 만들려면 프로그램 카운터, 스택 포인터, 메모리 버퍼 레스터, 메모리 주소 레지스터와 같이 하나의 명령어를 처리하기 위해 꼭  필요한 레지스터를 여러개 가지고 있으면 된다.
- 즉, ALU와 제어장치가 두 개의 필요 레지스터 세트에 저장된 명령어를 해석하고 실행하면 하나의 코어에서 두 개의 명령어가 동시에 실행되는 것이다.
- 이같은 경우 1코어 2스레드 CPU가 한 번에 2개의 명령어를 처리하는 것인데, 프로그램 입장에서는 한 번에 하나의 명령어를 처리하는 CPU가 두 개 있는 것처럼 보인다.
- 그래서 하드웨어 스레드를 **논리 프로세서(logical processor)**라고 부르기도 한다.

<br><br>

# 명령어 병렬 처리기법
- **명령어 병렬 처리 기법(ILP, Instruction-Level Parallelism)**은 명령어를 동시에 처리하여 CPU를 쉬지 않고 작동시키는 기법이다.

<br><br>

# 명령어 파이프라인
- 명령어 파이프라인을 이해하려면 하나의 명령어가 처리되는 전체 과정을 비슷한 시간 간격으로 나누어 보아야 한다.
- 클럭 단위로 명령어 처리 과정을 나누어보면 다음과 같다.
  1. 명령어 인출(instruction fetch)
  2. 명령어 해석(instruction decode)
  3. 명령어 실행(execute instruction)
  4. 결과 저장(write back)
- 여기서 중요한 점은 같은 단계가 겹치는 것이 아니면 CPU는 <u>각 단계를 동시에 실행할 수 있다</u>는 점이다.
- '인출'하는 동안, 다른 명령어를 '실행' 할수 있고 다른 경우도 같다.
- 명령어들을 **명령어 파이파라인(instruction pipeline)**에 넣고 동시에 처리하는 기법을 **명령어 파이프라이닝(instruction pipelining)**이라고 한다.
- 파이프라이닝은 높은 성능을 가져오지만 특정 상황엣서는 성능 향상에 실패하는 경우도 있는데 이를 **파이프라인 위험(pipeline hazard)**이라고 부른다.
- 파이프라인 위험에는 크게 데이터 위험, 제어 위험, 구조적 위험이 있다.

## 데이터 위험(data hazrard)
- **데이터 의존성**에 의해 발생한다.
- 어떤 명령어가 다른 명령어의 데이터에 의존한다면 두 명령어를 동시에 실행시키려고 할때 제대로 작동하지 않을 것이다.

## 제어 위험(control hazard)
- 주로 분기 등으로 인한 **프로그램 카운터의 갑작스러운 변화**에 의해 발생한다.
- 프로그램 실행 흐름이 바뀌어 명령어가 실행되며 프로그램 카운터 값에 변화가 생긴다면 명령어 파이프라인에 미리 가지고 와서 처리 중이었던 명령어들은 아무 쓸모가 없어진다(?)
- 이를 해결하기 위해 사용하는 기술 중 하나가 **분기 예측(branch prediction)**이다.
- 분기 예측은 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술이다.

## 구조적 위험(structural hazard)
- 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할때 발생.
- **자원 위험(resource hazard)**이라고도 부른다.

<br><br>

# 슈퍼스칼라(superscalar)
- CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조
- 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 '슈퍼스칼라 프로세서' 또는 '슈퍼스칼라 CPU'라고 한다.
- 멀티스레드 프로세서 같은 구조에서는 한 번에 여러 명령어를 인출, 해석, 실행이 가능하니 슈퍼스칼라 구조 사용이 가능하다.
- 파이프라인이 많으면 성능도 향상되겠지만 '파이프라인 위험' 등의 문제가 있어 실제로는 반드시 비례하여 성능이 좋아지지는 않음

<br><br>

# 비순차적 명령어 처리
- **비순차적 명령어 처리(OoOE, Out-of-Order execution)**은 OoOE로 줄여 부른다.
- 모든 명령어를 순차적으로만 처리한다면 파이프라인 위험등과 같은 문제들로 인해 명령어가 곧바로 처리되지 못하는 현상이 발생하기도 한다.
- 이런 경우 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 며령어 파이프라인이 멈추는 것을 방지하는 기법을 **비순차적 명령어 처리 기법**이라고 한다.

<br><br>

# 명령어 집합
- CPU가 이해할 수 있는 명령어들의 모음을 **명령어 집합(instruction set)** 혹은 **명령어 집합 구조(ISA, instruction set architecture)**라고 한다.
- CPU마다 ISA가 다를 수 있다.
- 명령어 집합 구조 라고 칭하는 이유는 CPU가 어떤 명령어를 이해하는지에 따라 컴퓨터 구조 및 설계 방식이 달라지기 때문
- 예로, 인텔 노트북 속 CPU는 x86, x86-64 ISA를 이해하고, 아이폰 속 CPU는 ARM ISA를 이해한다.
- 같은 소스 코드로 만들어진 같은 프로그램이라 할지라도 ISA가 다르면 CPU가 이해할 수 있는 명령어, 어셈블리어가 달라진다.
- 게다가 그에 따라 제어장치가 명령어를 해석하는 방식, 사용되는 레지스터의 종류와 개수, 메모리 관리 방법 등 많은 것이 달라진다.
- 즉, <u>ISA는 CPU의 언어임과 동시에 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속</u> 이다.
- 현대 ISA는 크게 CISC 와 RISC가 있다.

<br><br>

# CISC
- **CISC(Complex Instruction Set Computer)**는 복잡하고 다양한 명령어들을 활용하는 CPU 설계 방식이다. x86 등이 여기에 해당한다.
- 명령어의 형태와 크기가 다양한 **가변 길이 명령어**를 활용한다.
- 그에 따라 같은 일을 수행하는 프로그램이더라도 실행하는 명령어 수가 더 적으며, 컴파일된 프로그램의 크기가 더 작다.
- 메모리를 아끼며 개발하는 환경에 적합하다.
- 명령어가 복잡하고 다양하므로 명령어의 크기와 실행되기까지의 시간이 일정하지 않으며, 명령어 하나 실행하는 데 여러 클럭 주기를 필요로 하는 단점이 있다.
- 즉, 규격화되지 않은 명령어가 파이프라이닝을 어렵게 만든다.
- 그리고 대다수의 명령어는 잘 사용되지 않는다.


<br><br>

# RISC
- **RISC(Reduced Instruction Set Computer)**는 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향한다.
- **고정 길이 명령어**를 활용한다고 볼 수 있다.
- 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한할 만큼 메모리 접근을 단순화하고 최소화를 추구하며, 그래서 **load-store** 구조라고 부르기도 한다.
- 메모리에 대한 접근을 단순화, 최소화 하는 대신 레지스터를 적극적으로 활용한다.
- 주소 지정 방식도 적다.



<br><br>




# 정리
* 코어는 명령어를 실행할 수 있는 '하드웨어 부품'이다.
- 스레드는 '명령어를 실행하는 단위'이다
- 멀티코어 프로세서는 명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 두 개이상 있는 CPU를 의미하고,
- 멀티스레드 프로세서는 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU를 의미한다.
- 클럭 속도가 높은 CPU는 빠르게 작동한다
- 스레드에는 하드웨어적 스레드와 소프트웨어적 스레드가 있다
- 명령어 파이프라이닝은 동시에 여러 개의 명령어를 겹쳐 실행하는 기법이다.
- 슈퍼스칼라는 여러 개의 명령어 파이프라인을 두는 기법이다.
- 비순차적 명령어 처리 기법은 파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 기법
- ISA는 CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속이다.
- CISC는 복잡하고 다양한 종류의 가변 길이 명령어 집합을 활용한다,
- RISC는 단순하고 적은 종류의 고정 길이 명령어 집합을 활용한다.


