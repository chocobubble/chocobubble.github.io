---
title:  "[컴퓨터구조] 명령어"
excerpt: "혼공컴운"
excerpt_separator: "<!--more-->"
categories:
  - Architecture
tags:
  - Computer Architecture
  - Instruction

toc: true
toc_sticky: true
 
font-family: $happiness

use_math: true

date: 2023-06-07
last_modified_at: 2023-06-07
---

> '혼자 공부하는 컴퓨터구조+운영체제 - 강민철' 책을 참고하여 작성한 포스트입니다.

---

# 고급 언어와 저급 언어
* 고급 언어(high-level programming language)
    - 사람이 이해하고 작성하기 쉽게 만들어진 프로그래밍 언어
- 저급 언어(low-level programming language)
    - 컴퓨터가 이해하고 실행할 수 있는 언어
    - 명령어로 이루어져 있음
* 즉, 고급언어로 작성된 소스 코드가 실해오디려면 반드시 저급 언어인 명령어로 변환되어야 함
* 저급언어에는 기계어와 어셈블리어가 있다.
    - 기계어(machine code)
        - 0과 1의 명령어 비트로 이루어진 언어
        - 16진수로 표현하기도 한다
    - 어셈블리어(assembly language)
        - 기계어를 읽기 편한 형태로 번역한 언어

<br><br>

# 컴파일 언어와 인터프리터 언어
- 고급 언어는 명령어로 변환하는 방식에 따라 컴파일 언어와 인터프리터 언어로 나뉜다.

## 컴파일 언어
- 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어
- 이 변환 과정을 **컴파일(compile)**이라고 하며, 컴파일러를 통해 저급 언어로 변환된 코드를 **목적 코드(object code)**라고 한다.

## 인터프리터 언어
- 인터프리터(interpreter)에 의해 소스 코드가 한 줄 식 실행되는 고급 언어
- 소스 코드 한 줄씩 변환해 나가며 실행하므로 문법 오류 발생 전까지는 올바르게 수행된다.
- 컴파일 언어의 목적 코드는 컴퓨터가 이해하고 실행할 수 있는 저급 언어이기 때문에 인터프리터 언어가 더 느리다.

C, C++은 명확한 컴파일 언어지만 많은 프로그래밍 언어는 컴파일 언어와 인터프리터 언어의 경계가 모호한 경우가 많다!
{: .notice--info}

<br><br>

# 목적파일 vs 실행파일
* 목적 코드로 이루어진 파일을 목적 파일, 실행 코드로 이루어진 파일을 실행 파일 이라고 한다.
* 목적 코드가 실행 파일이 되기 위해서는 **링킹**이라는 작업을 거쳐야 한다.
* 목적 파일에 없는 외부기능들 (외부 파일들?) 과 연결 짓는 작업이 필요한데 이를 링킹(linking)이라고 한다.

<br><br>

# 연산 코드와 오퍼랜드
- 명령어는 연산 코드와 오퍼랜드로 구성되어 있다.
- 연산코드(operation code)
    - 명령어가 수행할 연산
    - 연산자라고도 불림
- 오퍼랜드(operand)
    - 연산에 사용할 데이터 혹은 연산에 사용할 데이터가 저장된 위치
    - 피연산자라고도 불림
- 명령어에서 연산 코드가 담기는 영역을 '연산 코드 필드'라고 하고, 오퍼랜드가 담기는 영역을 '오퍼랜드 필드'라고 부른다.
- 어셈블리어를 보면 앞에 연산 코드, 뒤에 오퍼랜드가 따라오는 것을 볼 수 있다.

## 오퍼랜드
- 오퍼랜드 필드에는 숫자나 문자 같은 데이터 혹은 메모리나 레지스터 주소가 올 수 있다.
- 많은 경우가 메모리 주소나 <u>레지스터 이름</u>이 담기므로 **주소 필드** 라고도 부른다.
- 명령어 안에 오퍼랜드가 없을 수도 있고 하나 또는 여러개가 있을 수도 있다.
- 각각 0-주소 명령어, 1-주소 명령어, 2-주소 명령어, 3-주소 명령어 라고 한다.

## 연산 코드
- 기본적인 연산 코드 유형은 4가지이다. cpu마다 다름. 아래는 대표적인 연산들
    1. 데이터 전송
        - move : 데이터 옮겨라
        - store: 메모리에 저장
        - load(fetch) : 메모리에서 CPU로 데이터를 가져와라
        - push: 스택에 데이터 저장
        - pop
    2. 산술/논리 연산
        - add,subtract,multiply,divide
        - increment, decrement
        - and, or, not
        - compare : 두 개의 숫자 또는 T/F 값 비교     
    3. 제어 흐름 변경
        - jump
        - conditional jump
        - halt : 프로그램의 실행 중단
        - call : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서 옮김
        - return : call 호출 떄 저장한 주소로 돌아감
    4. 입출력 제어
        - read(input)
        - write(output)
        - start io
        - test io

<br><br>

# 주소 지정 방식
- 오퍼랜드에 주소를 담는 이유는 명령어의 크기 때문이다.
- 명령어에서 연산 코드의 길이를 빼고, 오퍼랜드가 여러개라면, 하나의 오퍼랜드가 표현할 수 있는 데이터 크기는 매우 작아진다.
- 그래서 데이터가 존재하는 메모리 주소 혹은 레지스터의 이름을 명시한다.
- 이때 연산의 대상이 되는 데이터가 저장된 위치를 **유효 주소(effective address)**라고 한다.
- 연산에 사용할 데이터 위치를 찾는 방법을 **주소 지정 방식(addressing mode)**라고 한다.
- 현대 CPU는 다양한 주소 지정 방식이 있지만 크게 다섯 가지를 살펴 본다.

## 즉시 주소 지정 방식(immediate addressing mode)
- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
- 주소를 찾는 과정이 없으니 매우 빠르다.

## 직접 주소 지정 방식(direct addressing mode)
- 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식

## 간접 주소 지정 방식(indirect addressing mode)
- 유효 주소의 주소를 오퍼랜드 필드에 명시하는 방식
- 주소를 두번 찾아야 해서 느리다.

## 레지스터 주소 지정 방식(register addressing mode)
- 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방식
- 레지스터에 접근하는 것이 메모리에 접근하는 것보다 빠르므로 '직접 주소 지정 방식'보다 빠르다

## 레지스터 간접 주소 지정 방식(register indirect addressing mode)
- 연산에 사용할 데이터를 메모리에 저장하고,
- 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법이다.
- '간접 주소 지정 방식' 보단 빠르겠죠


<br><br>


# 정리
- 고급 언어는 사람이 이해하고 작성하기 쉽게 만들어진 언어
- 저급 언어는 컴퓨터가 직접 이해하고 실행할 수 있는 언어
- 저급 언어는 0과 1로 이루어진 명령어로 구성된 기계어와 기계어를 사람이 읽기 편한 형태로 번역한 어셈블리어가 있음
- 컴파일 언어는 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행 되는 언어
- 인터프리터 언어는 인터프리터에 의해 소스 코드가 한 줄씩 저급 언어로 변환되어 실행되는 언어
- 명령어는 연산 코드와 오퍼랜드로 구성됨
- 연산 코드는 명령어가 수행할 연산을 의미함
- 오퍼랜드는 연산에 사용할 데이터 혹은 연산에 사용할 데이터가 저장된 위치
- 주소 지정 방식은 연산에 사용할 데이터 위치를 찾는 방법


