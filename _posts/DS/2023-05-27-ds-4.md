---
title:  "자료 구조 - 큐"
excerpt: "C++로 쉽게 풀어쓴 자료구조 1판 - 천인국, 최영규"
excerpt_separator: "<!--more-->"
categories:
  - DS
tags:
  - DS, Queue

toc: true
toc_sticky: true
 
font-family: $happiness

date: 2023-05-27
last_modified_at: 2023-05-27
---
> 'c++로 쉽게 풀어쓴 자료구조 1판 - 천인국, 최영규' 책을 참고하여 작성한 포스트입니다.

# 큐(Queue)
* 큐는 자료의 입출력이 선입선출(FIFO: First-In First-Out)의 형태로 일어나는 자료구조를 말한다.
* 큐에서 삽입이 일어나는 곳을 후단(rear)이라고 하고 삭제가 일어나는 곳을 전단(front)라고 한다.

## 큐의 추상 자료형
스택과 유사하다
```
데이터: 선입선출의 접근 방법을 유지하는 요소들의 모음
연산
 - enqueue(e): 주어진 요소 e를 큐의 맨 뒤에 추가
 - dequeue(): 큐가 비어 있지 않으면 맨 앞에 있는 요소를 삭제하고 반환
 - isEmpty(): 큐가 비어 있으면 true, 그렇지 않으면 false 반환
 - peek(): 큐가 비어있지 않으면 맨 앞에 있는 요소를 삭제하지 않고 반환
 - isFull(): 큐가 가득 차 있으면 true, 그렇지 않으면 false 반환
 - size(): 큐 내의 모든 요소들의 개수를 반환
 - display(): 큐 내의 모든 요소들을 출력함
```

## 큐의 활용
컴퓨터 장치들 사이에서 데이터를 주고받을 때 각 장치들 사이에 존재하는 속도의 차이나 시간 차이를 극복하기 위한 임시 기억 장치로 큐가 사용되는데, 이것을 보통 버퍼(buffer)라고 부른다.

## 큐의 구현
* 선형 큐 : front와 rear의 값이 계속 증가하므로 언젠가는 배열의 끝에 도달하게 되어 더 이상 삽입하지 못하게 된다. 이 때 모든 요소들을 왼쪽으로 이동시켜야 하는데 그러면 삽입 연산의 시간 복잡도가 $O(n)$이 된다.
* 원형 큐 : 배열이 원형처럼 처음과 끝이 연결되어 있다고 가정한 큐이다. 배열의 끝에 도달하면 가리키는 인덱스를 0으로 바꾸어주면 된다. 그러면 배열이 포화되지 않는 이상 삽입과 큐는 끝없이 이루어질 수 있다.

---

### 원형 큐의 구현
```cpp
#include <cstdio>
#include <cstdlib>
#define MAX_QUEUE_SIZE 100
inline void printErrorMSG(char* message) {
    printf("%s\n", message);
    exit(1);
}

class CircularQueue {
protected:
    int front;
    int rear;
    int queue[MAX_QUEUE_SIZE];
public:
    CircularQueue() {
        front = 0;
        rear = 0;
    }

    bool isEmpty() {
        if(front == rear) {
            return true;
        } else {
            return false;
        }
    }

    bool isFull() {
        if(front == (rear+1)%MAX_QUEUE_SIZE) {
            return true;
        } else {
            return false;
        }
    }

    void enqueue(e) {
        if(isFull()) {
            printErrorMSG("queue is full");
        } else {
            queue[rear] = e;
            rear += 1;
        }
    }

    int dequeue() {
        if(isEmpty()) {
            printErrorMSG("queue is empty");
        } else {
            int n = queue[front];
            front = (front+1)%MAX_QUEUE_SIZE;
            return n;
        }
    }

    int peek() {
        if(isEmpty()) {
            printErrorMSG("queue is empty");
        } else {
            return queue[front];
        }
    }

    int size() {
        if(front > rear) {
            return 8 - front + rear;
        } else {
            return rear - front;
        }
    }

    void display() {
        if(front > rear) {
            for(int i=front; i<MAX_QUEUE_SIZE; i++) {
                printf("%d, ");
            }
            for(int i=0; i<=rear; i++) {
                printf("%d, ");
            }
        } else {
            for(int i=front; i<=rear; i++) {
                printf("%d, ");
            }
        }
        printf("\n");
    }
}
```