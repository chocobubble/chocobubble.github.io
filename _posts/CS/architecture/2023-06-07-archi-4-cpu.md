---
title:  "[컴퓨터구조] CPU의 작동 원리"
excerpt: "혼공컴운"
excerpt_separator: "<!--more-->"
categories:
  - Architecture
tags:
  - Computer Architecture
  - CPU

toc: true
toc_sticky: true
 
font-family: $happiness

use_math: true

date: 2023-06-07
last_modified_at: 2023-06-07
---

> '혼자 공부하는 컴퓨터구조+운영체제 - 강민철' 책을 참고하여 작성한 포스트입니다.

---

# ALU
- CPU 내부에서 계산을 담당한다.
- 연산한 결괏값과 플래그를 내보낸다.
- 레지스터를 통해 **피연산자**를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 **제어 신호**를 받는다.
- 연산한 결괏값은 특정 데이터가 될 수도 있고, 메모리 주소가 될 수도 있다. 바로 메모리에 저장되는 것이 아닌 일시적으로 레지스터에 저장된다.
- 메모리에 접근하는 것보다 레지스터에 접근하는 것이 훨씬 빠르기 때문
- 연산 결과에 대한 추가적인 상태 정보를 **플래그(flag)** 라고 한다.
    - 부호 플래그
        - 연산한 결과의 부호
        - 1이면 음수, 0이면 양수
    - 제로 플래그
        - 연산 결과가 0이면 1
    - 캐리 플래그
        - 연산 결과 올림수나 빌림수가 발생했는 지
        - 1이면 발생한 것
    - 오버플로우 플래그
        - 1이면 오버플로우 발생한 것
    - 인터럽트 플래그 
        - 1이면 인터럽트가 가능한 상태
    - 슈퍼바이저 플래그
        - 1이면 커널 모드로 실행 중임
        - 0이면 사용자 모드로 실행 중임
- 플래그들은 **플래그 레지스터**에 저장된다.
- 이 외에도 ALU 내부에는 여러 계산을 위한 회로들이 많이 있다.

<br><br>

# 제어장치
- 제어 신호를 내보내고, 명령어를 해석하는 부품
- 제어 신호는 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호이다.
- 제어장치가 받아들이는 정보는 4가지를 보자
    - 클럭 신호
        - 클럭(clock)이란 컴퓨터의 모든 부품을 주기에 맞춰 움직일 수 있게 하는 시간 단위이다.
        - 클럭의 주기에 맞춰 데이터가 이동하거나, 연산이 수행되거나, 명령어를 읽거나 한다.
        - 꼭 한 클럭에 완료해야 하는 것은 아님
    - 해석해야 할 명령어
        - CPU가 해석해야 할 명령어는 '명령어 레지스터'에 저장된다.
        - 제어장치는 이 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤,
        - 제어신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려준다.
    - 플래그 값
        - 플래그 레지스터 속 플래그 값을 받아들이고 이를 참고하여 제어 신호를 발생시킨다
    - 제어 신호
        - 시스템 버스 속 제어 버스로 부터 제어 신호를 받는다.
        - CPU뿐 아니라 입출력장치 같은 외부 장치도 제어 신호를 보낸다
- 제어창지가 내보내는 정보는 크게 CPU 외부에 전달하는 제어 신호와 내부에 전달하는 제어 신호로 나뉜다.
- 입출력 장치나 메모리에 전달하는 제어신호가 외부에 보내는 것이고,
- ALU나 레지스터에 전달하는 제어 신호가 내부에 전달하는 제어 신호다.
- ALU에는 수행할 연산을 지시하고, 레지스터에는 레지스터 간 데이터를 이동시키거나 레지스터에 저장된 명령어를 해석하기 위해 제어 신호를 보낸다.

<br><br>

# 레지스터
- 여러 레지스터가 있다.. 1. 프로그램 카운터, 2. 명령어 레지스터, 3. 메모리 주소 레지스터, 4. 메모리 버퍼 레지스터, 5. 플래그 레지스터, 6. 범용 레지스터, 7. 스택 포인터, 8. 베이스 레지스터 ....

## 프로그램 카운터(PC, program counter)
- 메모리에서 읽어들일 명령어의 **주소**를 저장한다.
- 명령어 포인터(IP, instruction pointer)라고도 불린다.

## 명령어 레지스터(IR, instruction register)
- 메모리에서 읽어 들인 해석할 명령어를 저장한다.
- 제어 장치는 명령어 레지스터 속 명령어를 받아 해석하고 제어 신호를 내보낸다고 했죠

## 메모리 주소 레지스터(MAR, memory address register)
- CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거친다.

## 메모리 버퍼 레지스터(MBR, memory buffer register)
- 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터
- 데이터 버스로 주고받을 값이 메모리 버퍼 레지스터를 거친다.

## 범용 레지스터(general purpose register)
- 데이터와 주소를 모두 저장 가능하다. 일반적으로 CPU 내 여러 개의 범용 레지스터가 있음.
- 일반적인 상황에서 자유롭게 사용 가능

## 플래그 레지스터(flag register)

<br><br>

# 특정 레지스터를 이용한 주소 지정 방식
## 1. 스택 주소 지정 방식
- 스택과 **스택 포인터(stack pointer)** 를 이용한다.
- 스택 포인터는 스택의 꼭대기를 가리키는 레지스터이다. 즉, 스택에 마지막으로 저장한 값의 위치를 저장하겠죠
- 스택은 메모리 상의 스택 영역에 있음!

## 2. 변위 주소 지정 방식(displacement addressing mode)
- 오퍼랜드의 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식.
- 이 방식의 명령어는 연산코드 + 레지스터 + 오퍼랜드 로 이루어져 있다.
- 레지스터와 오퍼랜드를 더한 곳에 있는 데이터를 가져온다.
- 어떤 레지스터와 더하느냐에 따라 상대 주소 지정 방식과 베이스 레지스터 주소 지정 방식으로 나뉜다.

### 상대 주소 지정 방식(relative addressing mode)
- 오퍼랜드와 '프로그램 카운터'의 갑승ㄹ 더해 유효 주소를 얻는다.
- 프로그램 카운터에는 <u>읽어들일 명령어가 담긴 메모리의 주소</u>가 있다. 이 주소에 오퍼랜드 값을 더해 얻음.
- 프로그램이 언어의 if문과 유사하다. 모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 때 사용한다

### 베이스 레지스터 주소 지정 방식(base-register addressing mode)
- 오퍼랜드와 **베이스 레지스터**의 값을 더하여 유효 주소를 얻는다.
- 베이스 레지스터 속 주소의 값과 오퍼랜드를 더해 얻는다.
(베이스 레지스터 나중에 설명)

[상용화된 CPU 속 레지스터 및 주소 지정 방식 - 혼공컴운 깃헙](https://github.com/kangtegong/self-learning-cs/blob/main/registers/registers.md#%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-arm-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0)


<br><br>


# 명령어 사이클(instruction cycle)
- CPU는 명령어들을 일정한 주기로 처리해 나가는데, 이 주기를 **명령어 사이클** 이라고 한다.
    1. 인출 사이클(fetch cycle)
        - 명령어를 처리하기 이해 메모리에서 CPU로 명령어를 가져오는 단계
    2. 실행 사이클(execution cycle)
        - 가져온 명령어를 실행하는 단계
        - 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시킴
    3. 간접 사이클(indirect cycle)
        - 가져온 명령어를 처리하는 데 메모리 접근을 더 해야 하는 경우 발생

<br><br>


# 인터럽트
* CPU의 작업을 잠시 중단시키는 신호를 **인터럽트(interrupt)** 라고 한다.
- 인터럽트는 크게 동기 인터럽트와 비동기 인터럽트로 나뉜다.
    - 동기 인터럽트(synchronous interrupt)
        - CPU에 의해 발생하는 인터럽트
        - 명령어 수행중 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트
        - **예외(exception)**이라고도 부름
    - 비동기 인터럽트(asynchronous interrupt)
        - 주로 입출력장치에 의해 발생하는 인터럽트
        - CPU가 입출력장치에 입출력 작업을 부탁했을 때 작업을 끝낸 입출력장치가 완료를 알리는 인터럽트를 보내고,
        - 입출력장치가 어떠한 입력을 받아들였을 때 입력을 알리는 인터럽트를 보낸다.
        - **하드웨어 인터럽트**라고도 부른다.

## 하드웨어 인터럽트
- CPU 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트를 사용한다.
- 하드웨어 인터럽트를 사용하면 완료 여부를 주기적으로 검사하지 않고, 인터럽트를 받을 때까지 다른 작업을 처리할 수 있다.

## 하드웨어 인터럽트 처리 순서
1. 입출력장치는 CPU에 **인터럽트 요청 신호**를 보낸다.
2. CPU는 실행 사이클이 끝나고 인출하기 전 항상 인터럽트 여부를 확인한다.
3. 인터럽트 요청이 있다면 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는 지 여부를 확인한다.
4. 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
5. **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행한다.
6. 인터럽트 서비스 루틴 실행이 끝나면 4.에서 백업해 둔 작업을 복구하여 실행을 재개한다.

- 인터럽트 중에서도 정전이나 하드웨어 고장 등으로 인한 인터럽트는 인터럽트 플래그로도 막을 수 없는 인터럽트이다.
- **인터럽트 서비스 루틴(ISR, interrupt service routine)**은 인터럽트를 처리하기 위한 프로그램이다.
    - **인터럽트 핸들러(interrupt handler)** 라고도 불린다.
    - 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램이다.
- 수많은 인터럽트 서비스 루틴을 구분하기 위해 **인터럽트 벡터(interrupt vector)**를 이용한다.
    - 인터럽트 벡터에 인터럽트 서비스 루틴의 메모리상 시작 주소가 나타나 있다.
    - 하드웨어 인터럽트 요청을 보낸 대상으로부터 데이터 버스를 통해 인터럽트 벡터를 전달받는다.
- 인터럽트 서비스 루틴도 프로그램이므로 명령어와 데이터로 이루어져 있고, 프로그램 카운터를 비롯한 레지스터를 사용하며 실행된다.
- 그래서 인터럽트 서비스 루틴을 실행 전 프로그램 실행을 재개하기 위한 모든 내용을 **스택**에 백업한다.
- 그러고 나서 인터럽트 서비스 루틴의 시작 주소가 위치한 곳으로 <u>프로그램 카운터 값</u>을 갱신하고 인터럽트 서비스 루틴을 실행한다.
- 인터럽트가 발생하면 명령어 사이클에 인터럽트 사이클도 추가된다(?원래 4개의 사이클로 이루어져 있다?)

<br><br>

# 예외의 종류
- 예외에는 폴트, 트랩, 중단, 소프트웨어 인터럽트가 있다
- **예외**가 발생하면 CPU는 하던 일을 중단하고 해당 예외를 처리한다.
- 처리하고 난 뒤 다시 본래 작업으로 되돌아와 실행을 재개한다.
- 폴트(fault)
    - 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외.
    - 페이지 폴트 등이 있네요
- 트랩(trap)
    - 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개.
    - 주로 디버깅할 때 사용
- 중단(abort)
    - CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류 발견 시 발생하는 예외
- 소프트웨어 인터럽트(software interrupt)
    - 시스템 호출 발생 시

<br><br>


# 정리

- ALU는 레지스터로부터 피연산자를 받고, 제어장치로부터 제어 신호를 받는다.
- ALU는 연산 결과와 플래그를 내보낸다.
- 제어장치는 클럭, 현재 수행할 명령어, 플래그, 제어 신호를 받아들인다.
- 제어장치는 CPU 내부와 외부로 제어 신허를 내보낸다.
- 프로그램 카운터는 메모리에서 가져올 명령어의 주소, 명령어 레지스터는 해석할 명령어를 저장한다.
- 메모리 주소 레지스터는 메모리의 주소, 메모리 버퍼 레지스터는 메모리와 주고받을 데이터를 저장한다.
- 범용 레지스터는 데이터와 주소를 모두 저장하고, 플래그 레지스터는 연산 결과 혹은 CPU 상태에 대한 부가 정보를 저장한다.
- 스택 포인터는 스택 최상단의 위치를 저장
- 베이스 레지스터에 저장된 주소는 기준 주소로서의 역할을 한다.
- 명령어 사이클은 하나의 명령어가 처리되는 주기로, 인출, 실행, 간접, 인터럽트 사이클로 구성되어 있다.
- 인터럽트는 CPu의 정상적인 작업을 방해하는 신호
- 인터럽트의 종류에는 예외와 하드웨어 인터럽트가 있다
- 인터럽트 서비스 루틴은 인터럽트를 처리하기 위한 동작들로 이루어진 프로그램.
