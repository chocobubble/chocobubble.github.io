---
title:  "동적 프로그래밍"
excerpt: "알고리즘"
excerpt_separator: "<!--more-->"
categories:
  - Algorithm
tags:
  - Algorithm
  - DP

toc: true
toc_sticky: true
use_math: true

date: 2023-09-01
last_modified_at: 2023-09-01
---

# 동적 프로그래밍

- 동적 프로그래밍은 부분 문제로 분해할 수 있는 최적화, 탐색, 계산 문제를 해결하기 위한 일반적인 방법을 말한다. 
- 동적 프로그래밍을 효율적으로 작성하려면 반복해서 발생하는 하위 문제의 결괏값을 캐싱(cashing) 해두어야 한다.
- 동적 프로그래밍을 효율적으로 푸는 핵심은 하나의 문제를 부분 문제로 나누는 방법을 찾는 것이다.
	- 부분 문제의 해법을 찾으면 원래 문제도 비교적 쉽게 해결할 수 있다.
	- 부분 문제의 해법을 캐시에 저장할 수 있다.

## 예시 
- 정수 배열이 주어졌을 때 합이 가장 큰 부분배열을 동적 프로그래밍으로 구해보자.
	1. 배열 A의 인덱스 i 이하의 모든 원소의 합계 최대 배열을 B라고 하자.
	2. 그러면 i를 포함해서 끝나는 최대 하위배열에 대한 두 가지 가능성만 존재한다.
		- 원소 A[i]이거나,
		- 이전 항목이 포함되는 경우 B[i-1] + A[i]다.
	3. 따라서 B[i] = max(A[i], B[i-1] + A[i])다. 
- ```A : [1, 3, -7, 5]```
- ```B : [1, 4, -3, 5]```

## 알고 있어야 할 내용

- 문제가 부분 문제와 관련이 있는 경우는 더더욱 동적 프로그래밍을 고려하자.
- **개수를 세는 문제, 의사 결정 문제**를 푸는 데도 쓸 수 있다. 
- 캐시는 효율성을 위해 **상향식**, 즉 반복적으로 구축되는 경우가 많다.

---

## 문제 16.1 가능한 점수가 몇 개인지 구하기

미식축구는 각 게임당 2점(세이프티), 3점(필드골), 7점(터치다운, 추가점수)을 낼 수 있다. 최종 점수와 각 게임에서 낼 수 있는 점수가 주어졌을 때, 주어진 최종 점수를 만들 수 있는 조합의 개수를 반환하라.

### 해법
- 2차원 배열 A[i][j]에 W[0], W[1], … , W[i-1]의 조합으로 점수 j를 만들 수 있는 개수를 저장해 보자. 

<details>
<summary> 응용 </summary>
<div markdown="3">       

- 같은 문제를 O(s)의 공간을 사용해 풀어 본다
- 최종 점수와 각 게임에서 낼 수 있는 점수가 주어졌을 때, 최종 점수를 만들 수 있는 수열의 개수를 반환하라. 예로 12점을 낼 수 있는 수열은 <2, 2, 2, 3, 3>, <2, 3, 2, 2, 3>, <2, 3, 7>, <7, 3, 2>를 포함해 총 열여덟가지 이다.
- 최종 점수가 (s, s’)의 꼴로 주어진다고 가정하자. 1번 팀은 최종적으로 s점을 내고 2번 팀은 최종적으로 s’점을 낸다는 뜻이다. 이와 같은 결과를 만들 수 있는 서로 다른 점수 수열의 개수는 어떻게 구할 수 있을까? 예로 최종 점수 (6, 3)을 만들 수 있는 한 가지 방법은 1번 팀이 3점을 내고, 그 다음 2번 팀이 3점을 내고, 1번 팀이 다시 3점을 내는 것이다.
- 최종 점수가 (s, s’)의 꼴로 주어졌을 때, 경기 중간에 역전되는 상황이 최대 몇 번이나 일어날 수 있는지 계산하라. 예를 들어  s = 10이고 s’=6일 때, 역전은 네 번 발생할 수 있다. 1번 팀이 2점 낸 뒤 2번 팀이 3점으로 역전, 1번 팀이 2점을 내서 다시 역전, 2번 팀이 3점을 내서 다시 역전, 1번팀이 3점을 내서 다시 역전, 마지막으로 1번 팀이 3점을 내면 10대 6으로 게임이 끝난다.

</div>
</details> 

---

## 문제 16.2 레벤슈타인 거리 구하기

문자열 두 개가 입력으로 주어졌을 때, 첫 번째 문자열에서 두 번째 문자열로 변환하는 데 필요한 최소 편집 횟수를 구하라.
	- 편집에는 삽입, 삭제, 치환이 있다.

### 해법
- 먼저 두 문자열을 각각 행, 열로 하는 2차원 배열을 만든다. 
- 마지막 바로 전의 최적해를 안다고 가정했을 때, 마지막 문자가 서로 같으면 + 0 하고 리턴
- 만약 다르다면,
	1. 두 문자 각 마지막 문자 바로 전까지 편집하고 난 후 치환
		- G[i][j] = G[i-1][j-1] + 1
	2. 첫 문자열 다 완성시키고 나서 나머지 한 문자열의 마지막 문자를 삭제
		- G[i][j] = G[i][j-1] + 1
	3. 첫 문자열의 마지막 문자를 빼고, 나머지 문자열을 모두 완성시키고 난 후 마지막 문자 삽입
		- G[i][j] = G[i-1][j] + 1


## 16.6 배낭 문제
- 가치와 무게가 정해진 여러 시계가 있다. 배낭의 무게 한도가 정해져 있을 때 가치가 최대가 되는 시계 집합을 구하라.

### 풀이
- 그리디로 풀 수 없다.
- 무게와 시계를 행과 열로 하는 2차원 배열을 먼저 만든다.
- 배열의 데이터는 해당 무게에서 해당 열까지의 시계를 조합한 최대 가치이다.
- V[i][w] = max( V[i][w] , V[i-1][w-wi]+vi ) 이다.


## 16.12 감소하지 않는 가장 긴 부분 수열 찾기
- 숫자 배열이 입력으로 주어졌을 때, 감소하지 않는 가장 긴 부분 수열의 길이를 반환하는 프로그램을 작성하라.


### 풀이
- 숫자 배열(A)의 길이만큼 최적해 배열(B)을 먼저 만든다.
- B[i]는 $j<i$ 를 만족하는 모든 j에 대해 $A[j]<B[i]$ 인 경우 B[i] = B[j]+1 이다.
	- 모든 j에 대해 $A[j]>B[i]$ 면 0.
	