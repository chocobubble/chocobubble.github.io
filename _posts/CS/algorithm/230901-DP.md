---
title:  "동적 프로그래밍"
excerpt: "알고리즘"
excerpt_separator: "<!--more-->"
categories:
  - Algorithm
tags:
  - Algorithm
  - DP

toc: true
toc_sticky: true
use_math: true

date: 2023-09-01
last_modified_at: 2023-09-01
---

# 동적 프로그래밍

- 동적 프로그래밍은 부분 문제로 분해할 수 있는 최적화, 탐색, 계산 문제를 해결하기 위한 일반적인 방법을 말한다. 
- 동적 프로그래밍을 효율적으로 작성하려면 반복해서 발생하는 하위 문제의 결괏값을 캐싱(cashing) 해두어야 한다.
- 동적 프로그래밍을 효율적으로 푸는 핵심은 하나의 문제를 부분 문제로 나누는 방법을 찾는 것이다.
	- 부분 문제의 해법을 찾으면 원래 문제도 비교적 쉽게 해결할 수 있다.
	- 부분 문제의 해법을 캐시에 저장할 수 있다.

## 예시 
- 정수 배열이 주어졌을 때 합이 가장 큰 부분배열을 동적 프로그래밍으로 구해보자.
	1. 모든 i<j에 대해 i까지의 최대 하위배열을 알고 있다고 가정한다.
	2. 이 최대 하위배열의 합계를 B[i]라고 하자. 그러면 j를 포함해서 끝나는 최대 하위배열에 대한 두 가지 가능성만 존재한다.
		- 원소 A[i]이거나,
		- 이전 항목이 포함되는 경우 B[i-1] + A[i]다.
	3. 따라서 B[i] = max(A[i], B[i-1] + A[i])다. 
	
```cpp
int FindMaximumSubarray(const vector<int>& A) {
	int max_seen = 0, max_end = 0;
	for (int a : A) {
		max_end = max(a, a + max_end);
		max_seen = max(max_end, max_seen);
	}
	return max_seen;
}
```

# 동적 프로그래밍 부트캠프

방금까지 살펴본 피보나치 수열과 최대 부분합을 구하는 문제는 동적 프로그래밍을 연습하기에 좋은 예제다.

# 동적 프로그래밍 문제를 풀기 전 꼭 알고 있어야 할 내용

- 문제가 부분 문제와 관련이 있는 경우는 더더욱 동적 프로그래밍을 고려하자.
- 동적 프로그래밍은 최적화 문제 뿐 아니라 **개수를 세는 문제, 의사 결정 문제**를 푸는 데도 쓸 수 있다. 동일한 계산을 재귀적으로 사용하는 작은 부분 문제들로 전체 문제를 표현할 수 있다면, 동적 프로그래밍으로 풀 수 있다.
- 이와 같은 개념으로 보자면, 동적 프로그래밍에는 재귀가 포함된다. 하지만 캐시는 효율성을 위해 **상향식**, 즉 반복적으로 구축되는 경우가 많다(문제16.3)
- 동적 프로그래밍이 재귀적으로 구현될 때, 캐시는 보통 해시 테이블이나 이진 탐색 트리 같은 동적 자료구조로 구현된다. 반복적으로 구현되는 캐시는 보통 1차원이나 다차원 배열이다.
- 공간을 절약하기 위해 다시 사용하지 않게 될 **캐시 공간**을 **재사용**수도 있다.(문제 16.1, 16.2)
- 가끔은 **상향식 동적 프로그래밍 해법보다 재귀가 더 효율적**일 때가 있다. 예로 해법을 빨리 찾을 수 있거나 **가지치기**를 통해 탐색해야 할 부분 문제의 개수를 줄이는 경우다(문제 16.5)
- 동적 프로그래밍은 부분 문제에 대한 **해법을 결합**하여 원래 문제에 대한 **해법을 제시**한다. 하지만 동적 프로그래밍으로도 풀 수 없는 문제도 있다. 예를 들어 가장 긴 경로를 구하는 문제다. 여기서는 어떤 노드도 반복하지 않는, 주어진 노드 쌍 사이의 가장 긴 경로를 찾아야 한다. 노드가 a, b, c, d고 간선이 (a, b), (b, c), (c, d), (d, a)인 경우, a에서 d로 가는 가장 긴 경로는 <a, b, c, d>이다. 하지만 여기서 일부 하위 경로 자체는 가장 긴 경로가 아니다. 예로 c에서 d로 가는 가장 긴 경로는 <c, d>가 아니라 <c, b, a, d>다. 반면에 가장 짧은 경로의 각 하위 경로는 그 자체가 가장 짧은 경로다.

---

# 문제 16.1 가능한 점수가 몇 개인지 구하기

미식축구는 각 게임당 2점(세이프티), 3점(필드골), 7점(터치다운, 추가점수)을 낼 수 있다. 최종 점수와 각 게임에서 낼 수 있는 점수가 주어졌을 때, 주어진 최종 점수를 만들 수 있는 조합의 개수를 반환하라.

힌트: 점수 w0을 0번 냈을 때, 점수 w0을 1번 냈을 때 등의 조합의 개수를 세어 보라.

낮은 점수를 통해 해법에 대한 감을 잡을 수 있다. 

무식한 방법은 수열을 모두 나열한 뒤 서로 다른 조합의 수열의 개수를 센다. 정렬하거나 해시 테이블을 사용할 수 있다. 시간 복잡도는 굉장히 높다. 원하는건 조합의 개수일 뿐이므로 조합을 모두 구하지 않고 답을 얻어 보자.

동적 프로그래밍을 이용해 보자. 2차원 배열 A[i][j]에 W[0], W[1], … , W[i-1]의 조합으로 점수 j를 만들 수 있는 개수를 저장해 보자. 예로 A[1][12]에는 2점과 3점으로 12점을 만들 수 있는 조합의 개수가 들어 있다. A[i+1][j]는 단순하게 A[i][j](즉, W[i+1]을 사용하지 않은 경우), A[i][j-W[i+1]](W[i+1]을 한 번 사용한 경우), A[i][j-2W[i+1]](W[i+1]을 두 번 사용한 경우) 등을 모두 더한 값이 된다.

이 알고리즘을 사용하려면 3중 루프를 사용해야 한다. 첫 번째 반복문은 구하고자 하는 점수, 두 번째 반복문은 각 게임의 점수가 될 것이다. i와 j가 주어졌을 때, 세 번째 반복문은 j/W[i] + 1번 반복한다.(예를 들어 j = 10, i = 1, W[i] = 3일 때, 세 번째 반복문은 A[0][10], A[0][7], A[0][4], A[0][1]의 값을 살펴본다.) 따라서 세 번째 반복문은 반복 횟수의 상한이 s와 같다. 전체 시간 복잡도는 첫 번째 반복문이 n, 두 번째 반복문이 n, 세 번째 반복문의 상한은 s이므로 O($s^2n$)이다.

A[i+1]의 행을 구하는 부분을 자세히 살펴보면, 좀 더 효율적으로 구할 수 있다. 예로 2점과 3점만으로 이루어진 게임을 생각해 보자. 2점 게임의 개수는 이미 구했다고 가정하자. 따라서 A[0]은 2점 게임의 결과를 포함한 행이 된다. 즉, A[0][j]는 2점으로 최종 점수 j를 만들 수 있는 조합의 개수이다. 여기에 3점 게임을 추가해서 최종 점수 12점을 만들 수 있는 조합의 개수는 A[0][0]+A[0][3]+A[0][6]+A[0][9]+A[0][12]와 같다. 최종 점수 15점을 만드는 조합의 개수는 A[0][0]+A[0][3]+A[0][6]+A[0][9]+A[0][12]+A[0][15]와 같다. 여기서 A[0][0]+A[0][3]+A[0][6]+A[0][9]+A[0][12] 부분이 중복됨을 알 수 있다.

A[1][15] = A[0][15] + A[1][12]와 같다. 이 점을 이용하면 A[1]의 행을 좀 더 효율적으로 구할 수 있다. A[1][0] = A[0][0], A[1][1] = A [0][1], A[1][2] = A[0][2], A[1][3] = A[0][3] + A[1][0], A[1][4] = A[0][4] + A[1][1], A[1][5] = A[0][5] + A[1][2], … 이 되므로 A[1][i] = A[0][i] + A[1][i-3]과 같다. 따라서 A[1][i]를 구하는 데 O(1)의 시간이 걸린다.

|  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 2 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |
| 2,3 | 0 | 0 | 1 | 1 | 1 | 1 | 2 | 1 | 2 | 2 | 2 | 2 | 3 |
| 2,3,7 | 1 | 0 | 1 | 1 | 1 | 1 | 2 | 2 | 2 | 3 | 3 | 3 | 4 |

```csharp
int NumCombinationsForFinalScore(int final_score,
																 const vector<int>& individual_play_scores) {
	vector<vector<int>> num_combinations_for_score(
			size(individual_play_scores), vector<int>(final_score + 1, 0));
	for (int i = 0; i < size(individual_play_scores); ++i) {
		num_combinations_for_score[i][0] = 1;  // 0점이 될 수 있는 방법의 개수
		for (int j = 1; j <= final_score; ++j) {
			int without_this_play = i >= 1 ? num_combinations_for_score[i - 1][j] : 0;
			int with_this_play =
					j >= individual_play_scores[i]
							? num_combinations_for_score[i][j-individual_play_scores[i]]
							: 0;
			num_combinations_for_score[i][j] = without_this_play + with_this_play;
		}
	}
	return num_combinations_for_score.back().back();
}
```

시간 복잡도는 O(sn)이다.(하나는 s, 하나는 n인 반복문 두 개) 공간 복잡도 또한 O(sn)이다.

## 응용

- 같은 문제를  O(s)의 공간을 사용해 풀어 보라
- 최종 점수와 각 게임에서 낼 수 있는 점수가 주어졌을 때, 최종 점수를 만들 수 있는 수열의 개수를 반환하라. 예로 12점을 낼 수 있는 수열은 <2, 2, 2, 3, 3>, <2, 3, 2, 2, 3>, <2, 3, 7>, <7, 3, 2>를 포함해 총 열여덟가지 이다.
- 최종 점수가 (s, s’)의 꼴로 주어진다고 가정하자. 1번 팀은 최종적으로 s점을 내고 2번 팀은 최종적으로 s’점을 낸다는 뜻이다. 이와 같은 결과를 만들 수 있는 서로 다른 점수 수열의 개수는 어떻게 구할 수 있을까? 예로 최종 점수 (6, 3)을 만들 수 있는 한 가지 방법은 1번 팀이 3점을 내고, 그 다음 2번 팀이 3점을 내고, 1번 팀이 다시 3점을 내는 것이다.
- 최종 점수가 (s, s’)의 꼴로 주어졌을 때, 경기 중간에 역전되는 상황이 최대 몇 번이나 일어날 수 있는지 계산하라. 예를 들어  s = 10이고 s’=6일 때, 역전은 네 번 발생할 수 있다. 1번 팀이 2점 낸 뒤 2번 팀이 3점으로 역전, 1번 팀이 2점을 내서 다시 역전, 2번 팀이 3점을 내서 다시 역전, 1번팀이 3점을 내서 다시 역전, 마지막으로 1번 팀이 3점을 내면 10대 6으로 게임이 끝난다.

---

# 문제 16.2 레벤슈타인 거리 구하기

문자열 두 개가 입력으로 주어졌을 때, 첫 번째 문자열에서 두 번째 문자열로 변환하는 데 필요한 최소 편집 횟수를 구하라.

힌트: 범위를 좁혀서 두 문자열의 접두사를 대상으로 동일한 문제를 풀어 보자.

나은 방법은 탐색 도중 ‘가지치는’ 방법이다. 예로 첫 번째 문자열의 마지막 문자가 두 번째 문자열의 마지막 문자와 같다면, 이 문자는 무시해도 된다. 만약 이들이 다르다면, 기존 문자열에 초점을 맞춰 최종 편집을 수행하면 된다.(최종 편집은 삽입, 삭제, 치환 중 하나다)