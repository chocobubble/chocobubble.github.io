---
title:  "그리디"
excerpt: "알고리즘"
excerpt_separator: "<!--more-->"
categories:
  - Algorithm
tags:
  - Algorithm
  - string

toc: true
toc_sticky: true
use_math: true

date: 2023-09-01
last_modified_at: 2023-09-01
---

# 그리디 알고리즘

> 그리디 알고리즘은 해법을 단계적으로 계산한다. 각 단계마다 지역적으로(locally) 최적의 결정을 내리며, 이 결정은 절대 변경되지 않는다.

> 그리디 알고리즘이 늘 최적의 해법을 생성하는 것은 아니다. 때로는 문제에 대한 그리디 알고리즘이 여러 개 존재하며, 이들 중 일부만 최적의 해법을 제공하기도 한다.

## 알아야 할 내용
- 일반적인 형태의 동전 교환 문제는 NP-난해(hard) 문제이다. 
	- 일부 동전 교환 문제만 그리디 알고리즘으로 해결 가능하다.
		- 동전의 단위가 1, r, $r^2$, $r^3$ ... 인 경우
		- 미국 동전같은 경우
			- 1, 5, 10, 25, 50, 100

- 그리디 알고리즘은 보통, **각 단계에서 가장 최선의 선택**을 할 수 있는 **최적화 문제**에 적합한 선택이다.
- 그리디 알고리즘을 재귀적으로 추상화한 뒤에, 성능 향상을 위해 반복문을 써서 **구현**하면 더 쉬운 경우가 많다.
- 그리디 방법이 최적 해법을 찾지 못하더라도, 최적 알고리즘을 찾는 통찰력 혹은 휴리스틱에 대한 힌트가 될 수 있다.
- 때로는 어떤 그리디 알고리즘을 선택해야 올바른지 **명확하지 않은** 경우도 있다.



# 불변식
- 불변식은 프로그램이 실행되는 동안 참인 조건을 말한다.
	- 변수 값이나 제어 논리에 있을 수 있다.

## 예시
- 예를 들어 정렬된 숫자 배열에서 두 숫자를 골라 특정 숫자를 만든다고 해보자.
- 특정 구간의 가장 작은 값과 가장 큰 값을 더했을 때 원하는 숫자보다 작다면, 구간 내에서는 가장 작은 값과 다른 어떠한 값을 더하더라도 원하는 숫자보다 작을 수 밖에 없다. 
	- 이런 불변식을 이용해 풀어나갈 수 있다.

```cpp
bool hasTwoSome(const vector<int> A, int t) {
	int i=0, j = size(A) - 1;
	while (i <= j) {
		if (A[i] + A[j] == t) return true;
		else if(A[i] + A[j] < t) ++i;
		else --j; //A[i] + A[j] > t
	}
	return false;
}
```

## 알아야 할 내용
- 불변식 사용 여부를 결정하려면 먼저 **작은 예제**를 통해 가정한 불변식이 맞는지 확인해야 한다.
- 종종 불변식은 가능한 입력 집합의 부분 집합(부분 배열 등)이 된다.



> '266가지 문제로 정복하는 코딩 인터뷰 - 아다드 아지즈, 쭝시엔 리, 아트 프라카시 지음 - 이창현, 김현욱 옮김' 책을 참고하여 작성한 포스트입니다.